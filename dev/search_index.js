var documenterSearchIndex = {"docs":
[{"location":"orthonormal_bases.html#Orthonormal-bases-1","page":"Orthonormal bases","title":"Orthonormal bases","text":"","category":"section"},{"location":"orthonormal_bases.html#","page":"Orthonormal bases","title":"Orthonormal bases","text":"The following functions and types provide support for orthonormal bases of the tangent space of different manifolds. An orthonormal basis of the tangent space T_x M of (real) dimension N has a real-coefficient basis e_1 e_2 dots e_N if mathrmRe(g_x(e_i e_j)) = delta_ij for each ij in 1 2 dots N where g_x is the Riemannian metric at point x. A vector v from the tangent space T_x M can be expressed as a sum v = v^i e_i where coefficients v^i are calculated as v^i = mathrmRe(g_x(v e_i)).","category":"page"},{"location":"orthonormal_bases.html#","page":"Orthonormal bases","title":"Orthonormal bases","text":"The main types are:","category":"page"},{"location":"orthonormal_bases.html#","page":"Orthonormal bases","title":"Orthonormal bases","text":"ArbitraryOrthonormalBasis, which is designed to work when no special properties of the tangent space basis are required.  It is designed to make get_coordinates and get_vector fast.\nDiagonalizingOrthonormalBasis, which diagonalizes the curvature tensor and makes the curvature in the selected direction equal to 0.\nProjectedOrthonormalBasis, which projects a basis of the ambient space and orthonormalizes projections to obtain a basis in a generic way.\nSubtypes of AbstractPrecomputedOrthonormalBasis, which work by storing (either explicitly or implicitly) a precomputed basis at a certain point. ArbitraryOrthonormalBasis doesn't require precomputing but DiagonalizingOrthonormalBasis and DiagonalizingOrthonormalBasis usually do.","category":"page"},{"location":"orthonormal_bases.html#","page":"Orthonormal bases","title":"Orthonormal bases","text":"The main functions are:","category":"page"},{"location":"orthonormal_bases.html#","page":"Orthonormal bases","title":"Orthonormal bases","text":"get_basis precomputes a basis at a certain point.\nget_coordinates returns coordinates of a tangent vector.\nget_vector returns a vector for the specified coordinates.\nget_vectors returns a vector of basis vectors (calling it should be avoided for high-dimensional manifolds).","category":"page"},{"location":"orthonormal_bases.html#","page":"Orthonormal bases","title":"Orthonormal bases","text":"Modules = [Manifolds]\nPages = [\"orthonormal_bases.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"orthonormal_bases.html#Manifolds.AbstractBasis","page":"Orthonormal bases","title":"Manifolds.AbstractBasis","text":"AbstractBasis{F}\n\nAbstract type that represents a basis on a manifold or a subset of it.\n\nThe type parameter F denotes the AbstractNumbers that will be used as scalars.\n\n\n\n\n\n","category":"type"},{"location":"orthonormal_bases.html#Manifolds.AbstractOrthonormalBasis","page":"Orthonormal bases","title":"Manifolds.AbstractOrthonormalBasis","text":"AbstractOrthonormalBasis{F}\n\nAbstract type that represents an orthonormal basis on a manifold or a subset of it.\n\nThe type parameter F denotes the AbstractNumbers that will be used as scalars.\n\n\n\n\n\n","category":"type"},{"location":"orthonormal_bases.html#Manifolds.AbstractPrecomputedOrthonormalBasis","page":"Orthonormal bases","title":"Manifolds.AbstractPrecomputedOrthonormalBasis","text":"AbstractPrecomputedOrthonormalBasis{F}\n\nAbstract type that represents an orthonormal basis of the tangent space at a point on a manifold. Tangent vectors can be obtained using function get_vectors.\n\nThe vectors are not always fully precomputed because a partially precomputed basis may be enough for implementing get_vector and get_coordinates.\n\nThe type parameter F denotes the AbstractNumbers that will be used as scalars.\n\n\n\n\n\n","category":"type"},{"location":"orthonormal_bases.html#Manifolds.ArbitraryOrthonormalBasis","page":"Orthonormal bases","title":"Manifolds.ArbitraryOrthonormalBasis","text":"ArbitraryOrthonormalBasis(F::AbstractNumbers = â„)\n\nAn arbitrary orthonormal basis on a manifold. This will usually be the fastest orthonormal basis available for a manifold.\n\nThe type parameter F denotes the AbstractNumbers that will be used as scalars.\n\n\n\n\n\n","category":"type"},{"location":"orthonormal_bases.html#Manifolds.DiagonalizingOrthonormalBasis","page":"Orthonormal bases","title":"Manifolds.DiagonalizingOrthonormalBasis","text":"DiagonalizingOrthonormalBasis(v, F::AbstractNumbers = â„)\n\nAn orthonormal basis Îž as a vector of tangent vectors (of length determined by manifold_dimension) in the tangent space that diagonalizes the curvature tensor R(uv)w and where the direction v has curvature 0.\n\nThe type parameter F denotes the AbstractNumbers that will be used as scalars.\n\n\n\n","category":"type"},{"location":"orthonormal_bases.html#Manifolds.PrecomputedDiagonalizingOrthonormalBasis","page":"Orthonormal bases","title":"Manifolds.PrecomputedDiagonalizingOrthonormalBasis","text":"DiagonalizingOrthonormalBasis(vectors, kappas, F::AbstractNumbers = â„)\n\nA precomputed orthonormal basis Îž as a vector of tangent vectors (of length determined by manifold_dimension) in the tangent space that diagonalizes the curvature tensor R(uv)w with eigenvalues kappas and where the direction v has curvature 0.\n\nThe type parameter F denotes the AbstractNumbers that will be used as scalars.\n\n\n\n","category":"type"},{"location":"orthonormal_bases.html#Manifolds.PrecomputedOrthonormalBasis","page":"Orthonormal bases","title":"Manifolds.PrecomputedOrthonormalBasis","text":"PrecomputedOrthonormalBasis(vectors::AbstractVector, F::AbstractNumbers = â„)\n\nA precomputed orthonormal basis at a point on a manifold.\n\nThe type parameter F denotes the AbstractNumbers that will be used as scalars.\n\n\n\n\n\n","category":"type"},{"location":"orthonormal_bases.html#Manifolds.ProjectedOrthonormalBasis","page":"Orthonormal bases","title":"Manifolds.ProjectedOrthonormalBasis","text":"ProjectedOrthonormalBasis(method::Symbol, F::AbstractNumbers = â„)\n\nAn orthonormal basis that comes from orthonormalization of basis vectors of the ambient space projected onto the subspace representing the tangent space at a given point.\n\nThe type parameter F denotes the AbstractNumbers that will be used as scalars.\n\nAvailable methods:\n\n:gram_schmidt uses a modified Gram-Schmidt orthonormalization.\n:svd uses SVD decomposition to orthogonalize projected vectors. The SVD-based method should be more numerically stable at the cost of an additional assumption (local metric tensor at a point where the basis is calculated has to be diagonal).\n\n\n\n\n\n","category":"type"},{"location":"orthonormal_bases.html#Manifolds.get_basis-Tuple{Manifold,Any,AbstractBasis}","page":"Orthonormal bases","title":"Manifolds.get_basis","text":"get_basis(M::Manifold, x, B::AbstractBasis) -> AbstractBasis\n\nCompute the basis vectors of the tangent space at a point on manifold M represented by x.\n\nReturned object derives from AbstractBasis and may have a field .vectors that stores tangent vectors or it may store them implicitly, in which case the function get_vectors needs to be used to retrieve the basis vectors.\n\nSee also: get_coordinates, get_vector\n\n\n\n\n\n","category":"method"},{"location":"orthonormal_bases.html#Manifolds.get_basis-Tuple{Manifold,Any,ArbitraryOrthonormalBasis}","page":"Orthonormal bases","title":"Manifolds.get_basis","text":"get_basis(M::Manifold, x, B::ArbitraryOrthonormalBasis)\n\nCompute the basis vectors of an ArbitraryOrthonormalBasis.\n\n\n\n\n\n","category":"method"},{"location":"orthonormal_bases.html#Manifolds.get_coordinates-Tuple{Manifold,Any,Any,AbstractBasis}","page":"Orthonormal bases","title":"Manifolds.get_coordinates","text":"get_coordinates(M::Manifold, x, v, B::AbstractBasis)\n\nCompute a one-dimensional vector of coefficients of the tangent vector v at point denoted by x on manifold M in basis B.\n\nDepending on the basis, x may not directly represent a point on the manifold. For example if a basis transported along a curve is used, x may be the coordinate along the curve.\n\nSee also: get_vector, get_basis\n\n\n\n\n\n","category":"method"},{"location":"orthonormal_bases.html#Manifolds.get_vector-Tuple{Manifold,Any,Any,AbstractBasis}","page":"Orthonormal bases","title":"Manifolds.get_vector","text":"get_vector(M::Manifold, x, v, B::AbstractBasis)\n\nConvert a one-dimensional vector of coefficients in a basis B of the tangent space at x on manifold M to a tangent vector v at x.\n\nDepending on the basis, x may not directly represent a point on the manifold. For example if a basis transported along a curve is used, x may be the coordinate along the curve.\n\nSee also: get_coordinates, get_basis\n\n\n\n\n\n","category":"method"},{"location":"orthonormal_bases.html#Manifolds.get_vectors-Tuple{Manifold,Any,AbstractBasis}","page":"Orthonormal bases","title":"Manifolds.get_vectors","text":"get_vectors(M::Manifold, x, B::AbstractBasis)\n\nGet the basis vectors of basis B of the tangent space at point x.\n\n\n\n\n\n","category":"method"},{"location":"orthonormal_bases.html#Manifolds.number_system-Union{Tuple{AbstractBasis{F}}, Tuple{F}} where F","page":"Orthonormal bases","title":"Manifolds.number_system","text":"number_system(::AbstractBasis)\n\nThe number system used as scalars in the given basis.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals.html#Internal-documentation-1","page":"Internals","title":"Internal documentation","text":"","category":"section"},{"location":"lib/internals.html#","page":"Internals","title":"Internals","text":"Documentation for Manifolds.jl's internal methods and types.","category":"page"},{"location":"lib/internals.html#Types-1","page":"Internals","title":"Types","text":"","category":"section"},{"location":"lib/internals.html#","page":"Internals","title":"Internals","text":"Manifolds.SizedAbstractArray","category":"page"},{"location":"lib/internals.html#Manifolds.SizedAbstractArray","page":"Internals","title":"Manifolds.SizedAbstractArray","text":"SizedAbstractArray{Tuple{dims...}}(array)\n\nWraps an AbstractArray with a static size, so to take advantage of the (faster) methods defined by the static array package. The size is checked once upon construction to determine if the number of elements (length) match, but the array may be reshaped.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals.html#Functions-1","page":"Internals","title":"Functions","text":"","category":"section"},{"location":"lib/internals.html#","page":"Internals","title":"Internals","text":"Manifolds._gradient\nManifolds._jacobian\nManifoldsBase.allocate_result_type\nManifolds.eigen_safe\nManifolds.find_pv\nManifolds.log_safe\nManifoldsBase.number_eltype\nManifolds.size_to_tuple\nManifolds.select_from_tuple\nManifolds.usinc\nManifolds.usinc_from_cos\nManifolds.ziptuples","category":"page"},{"location":"lib/internals.html#Manifolds._gradient","page":"Internals","title":"Manifolds._gradient","text":"_gradient(f, x::Number, backend = adbackend()) -> Number\n_gradient(f, x::Array, backend = adbackend()) -> Array\n\nCompute gradient of function f at point x using AD backend backend.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals.html#Manifolds._jacobian","page":"Internals","title":"Manifolds._jacobian","text":"_jacobian(f, x::Array, backend = adbackend()) -> Array\n\nCompute Jacobian matrix of function f at point x using AD backend backend. Inputs and outputs of f are vectorized.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals.html#ManifoldsBase.allocate_result_type","page":"Internals","title":"ManifoldsBase.allocate_result_type","text":"allocate_result_type(B::VectorBundleFibers, f, args::NTuple{N,Any}) where N\n\nReturns type of element of the array that will represent the result of function f for representing an operation with result in the vector space VS for manifold M on given arguments (passed at a tuple).\n\n\n\n\n\nallocate_result_type(M::Manifold, f, args::NTuple{N,Any}) where N\n\nReturn type of element of the array that will represent the result of function f for manifold M on given arguments args (passed as a tuple).\n\n\n\n\n\n","category":"function"},{"location":"lib/internals.html#Manifolds.eigen_safe","page":"Internals","title":"Manifolds.eigen_safe","text":"eigen_safe(x)\n\nCompute the eigendecomposition of x. If x is a StaticMatrix, it is converted to a Matrix before the decomposition.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals.html#Manifolds.find_pv","page":"Internals","title":"Manifolds.find_pv","text":"find_pv(x...)\n\nA = find_pv(x...) returns the first ProductArray among the arguments.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals.html#Manifolds.log_safe","page":"Internals","title":"Manifolds.log_safe","text":"log_safe(x)\n\nCompute the matrix logarithm of x. If x is a StaticMatrix, it is converted to a Matrix before computing the log.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals.html#ManifoldsBase.number_eltype","page":"Internals","title":"ManifoldsBase.number_eltype","text":"number_eltype(x)\n\nNumeric element type of the a nested representation of a point or a vector. To be used in conjuntion with allocate or allocate_result.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals.html#Manifolds.size_to_tuple","page":"Internals","title":"Manifolds.size_to_tuple","text":"size_to_tuple(::Type{S}) where S<:Tuple\n\nConverts a size given by Tuple{N, M, ...} into a tuple (N, M, ...).\n\n\n\n\n\n","category":"function"},{"location":"lib/internals.html#Manifolds.select_from_tuple","page":"Internals","title":"Manifolds.select_from_tuple","text":"select_from_tuple(t::NTuple{N, Any}, positions::Val{P})\n\nSelects elements of tuple t at positions specified by the second argument. For example select_from_tuple((\"a\", \"b\", \"c\"), Val((3, 1, 1))) returns (\"c\", \"a\", \"a\").\n\n\n\n\n\n","category":"function"},{"location":"lib/internals.html#Manifolds.usinc","page":"Internals","title":"Manifolds.usinc","text":"usinc(Î¸::Real)\n\nUnnormalized version of sinc function, i.e. operatornameusinc(theta) = fracsin(theta)theta. This is equivalent to sinc(Î¸/Ï€).\n\n\n\n","category":"function"},{"location":"lib/internals.html#Manifolds.usinc_from_cos","page":"Internals","title":"Manifolds.usinc_from_cos","text":"usinc_from_cos(x::Real)\n\nUnnormalized version of sinc function, i.e. operatornameusinc(theta) = fracsin(theta)theta, computed from x = cos(theta).\n\n\n\n","category":"function"},{"location":"lib/internals.html#Manifolds.ziptuples","page":"Internals","title":"Manifolds.ziptuples","text":"ziptuples(a, b[, c[, d[, e]]])\n\nZips tuples a, b, and remaining in a fast, type-stable way. If they have different lengths, the result is trimmed to the length of the shorter tuple.\n\n\n\n\n\n","category":"function"},{"location":"manifolds/choleskyspace.html#Cholesky-space-1","page":"Cholesky space","title":"Cholesky space","text":"","category":"section"},{"location":"manifolds/choleskyspace.html#","page":"Cholesky space","title":"Cholesky space","text":"The Cholesky space is a Riemannian manifold on the lower triangular matrices.","category":"page"},{"location":"manifolds/choleskyspace.html#","page":"Cholesky space","title":"Cholesky space","text":"Modules = [Manifolds]\nPages = [\"manifolds/CholeskySpace.jl\"]\nOrder = [:type]","category":"page"},{"location":"manifolds/choleskyspace.html#Manifolds.CholeskySpace","page":"Cholesky space","title":"Manifolds.CholeskySpace","text":"CholeskySpace{N} <: Manifold\n\nThe manifold of lower triangular matrices with positive diagonal and a metric based on the cholesky decomposition. The formulae for this manifold are for example summarized in Table 1 of [Lin2019].\n\nConstructor\n\nCholeskySpace(n)\n\nGenerate the manifold of ntimes n lower triangular matrices with positive diagonal.\n\n[Lin2019]: Lin, Zenhua: \"Riemannian Geometry of Symmetric Positive Definite Matrices via Cholesky Decomposition\", arXiv: 1908.09326.\n\n\n\n","category":"type"},{"location":"manifolds/choleskyspace.html#","page":"Cholesky space","title":"Cholesky space","text":"Modules = [Manifolds]\nPages = [\"manifolds/CholeskySpace.jl\"]\nOrder = [:function]","category":"page"},{"location":"manifolds/choleskyspace.html#Base.exp-Tuple{CholeskySpace,Vararg{Any,N} where N}","page":"Cholesky space","title":"Base.exp","text":"exp(M::CholeskySpace, x, v)\n\nCompute the exponential map on the CholeskySpace M eminating from the lower triangular matrix with positive diagonal x towards the lower triangular matrix v The formula reads\n\nexp_x v = lfloor x rfloor + lfloor v rfloor + operatornamediag(x)\noperatornamediag(x)expbigl( operatornamediag(v)operatornamediag(x)^-1bigr)\n\nwhere lfloor xrfloor denotes the strictly lower triangular matrix of x and operatornamediag(x) the diagonal matrix of x\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#Base.log-Tuple{LinearAlgebra.Cholesky,Vararg{Any,N} where N}","page":"Cholesky space","title":"Base.log","text":"log(M::CholeskySpace, v, x, y)\n\nCompute the logarithmic map on the CholeskySpace M for the geodesic eminating from the lower triangular matrix with positive diagonal x towards y. The formula reads\n\nlog_x v = lfloor x rfloor - lfloor y rfloor\n+operatornamediag(x)logbigl(operatornamediag(y)operatornamediag(x)^-1bigr)\n\nwhere lfloor xrfloor denotes the strictly lower triangular matrix of x and operatornamediag(x) the diagonal matrix of x\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#ManifoldsBase.distance-Tuple{CholeskySpace,Any,Any}","page":"Cholesky space","title":"ManifoldsBase.distance","text":"distance(M::CholeskySpace, x, y)\n\nCompute the Riemannian distance on the CholeskySpace M between two matrices x, y that are lower triangular with positive diagonal. The formula reads\n\nd_mathcal M(xy) = sqrtsum_ij (x_ij-y_ij)^2 +\nsum_j=1^m (log x_jj - log y_jj)^2\n\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#ManifoldsBase.inner-Tuple{CholeskySpace,Any,Any,Any}","page":"Cholesky space","title":"ManifoldsBase.inner","text":"inner(M::CholeskySpace, x, v, w)\n\nCompute the inner product on the CholeskySpace M at the lower triangular matric with positive diagonal x and the two tangent vectors v,w, i.e they are both lower triangular matrices with arbitrary diagonal. The formula reads\n\n    g_x(vw) = sum_ij v_ijw_ij + sum_j=1^m v_iiw_iix_ii^-2\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#ManifoldsBase.manifold_dimension-Union{Tuple{CholeskySpace{N}}, Tuple{N}} where N","page":"Cholesky space","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::CholeskySpace)\n\nReturn the manifold dimension for the CholeskySpace M, i.e. fracN(N+1)2.\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#ManifoldsBase.representation_size-Union{Tuple{CholeskySpace{N}}, Tuple{N}} where N","page":"Cholesky space","title":"ManifoldsBase.representation_size","text":"reporesentation_size(M::CholeskySpace)\n\nReturn the representation size for the CholeskySpace{N} M, i.e. (N,N).\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#ManifoldsBase.vector_transport_to-Tuple{CholeskySpace,Any,Any,Any,ParallelTransport}","page":"Cholesky space","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::CholeskySpace, x, v, y, ::ParallelTransport)\n\nParallely transport the tangent vector v at x along the geodesic to y on to the CholeskySpace manifold M. The formula reads\n\nmathcal P_ygets x(v) = lfloor v rfloor\n+ operatornamediag(y)operatornamediag(x)^-1operatornamediag(v)\n\nwhere lfloorcdotrfloor denotes the strictly lower triangular matrix, and operatornamediag extracts the diagonal matrix.\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#ManifoldsBase.zero_tangent_vector-Tuple{CholeskySpace,Vararg{Any,N} where N}","page":"Cholesky space","title":"ManifoldsBase.zero_tangent_vector","text":"zero_tangent_vector(M::CholeskySpace, x)\n\nReturn the zero tangent vector on the CholeskySpace M at x.\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#ManifoldsBase.check_manifold_point-Tuple{CholeskySpace,Any}","page":"Cholesky space","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::CholeskySpace, x; kwargs...)\n\nCheck whether the matrix x lies on the CholeskySpace M, i.e. it's size fits the manifold, it is a lower triangular matrix and has positive entries on the diagonal. The tolerance for the tests can be set using the kwargs....\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#ManifoldsBase.check_tangent_vector-Tuple{CholeskySpace,Any,Any}","page":"Cholesky space","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::CholeskySpace, x, v; kwargs... )\n\nChecks whether v is a tangent vector to x on the CholeskySpace M, i.e. atfer check_manifold_point(M,x), v has to be of same dimension as x and a symmetric matrix. The tolerance for the tests can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#Literature-1","page":"Cholesky space","title":"Literature","text":"","category":"section"},{"location":"manifolds/metric.html#Metric-manifold-1","page":"Metric manifold","title":"Metric manifold","text":"","category":"section"},{"location":"manifolds/metric.html#","page":"Metric manifold","title":"Metric manifold","text":"A Riemannian manifold always consists of a topological manifold together with a smoothly varying metric g.","category":"page"},{"location":"manifolds/metric.html#","page":"Metric manifold","title":"Metric manifold","text":"However, often there is an implicitly assumed (default) metric, like the usual inner product on Euclidean space. This decorator takes this into account. It is not necessary to use this decorator if you implement just one (or the first) metric. If you later introduce a second, the old (first) metric can be used with the (non MetricManifold) Manifold, i.e. without an explicitly stated metric. The decorator acts transparent in that sense; see is_decorator_manifold for details.","category":"page"},{"location":"manifolds/metric.html#","page":"Metric manifold","title":"Metric manifold","text":"This manifold decorator serves two purposes:","category":"page"},{"location":"manifolds/metric.html#","page":"Metric manifold","title":"Metric manifold","text":"to implement different metrics (e.g. in closed form) for one Manifold 2. to provide a way to compute geodesics on manifolds, where this Metric does not yield closed formula.","category":"page"},{"location":"manifolds/metric.html#","page":"Metric manifold","title":"Metric manifold","text":"Let's first look at the provided types.","category":"page"},{"location":"manifolds/metric.html#Types-1","page":"Metric manifold","title":"Types","text":"","category":"section"},{"location":"manifolds/metric.html#","page":"Metric manifold","title":"Metric manifold","text":"Modules = [Manifolds, ManifoldsBase]\nPages = [\"manifolds/MetricManifold.jl\"]\nOrder = [:type]","category":"page"},{"location":"manifolds/metric.html#Manifolds.LorentzMetric","page":"Metric manifold","title":"Manifolds.LorentzMetric","text":"LorentzMetric <: Metric\n\nAbstract type for Lorentz metrics, which have a single time dimension. These metrics assume the spacelike convention with the time dimension being last, giving the signature (+++-).\n\n\n\n","category":"type"},{"location":"manifolds/metric.html#Manifolds.Metric","page":"Metric manifold","title":"Manifolds.Metric","text":"Metric\n\nAbstract type for the pseudo-Riemannian metric tensor g, a family of smoothly varying inner products on the tangent space. See inner.\n\n\n\n","category":"type"},{"location":"manifolds/metric.html#Manifolds.MetricManifold","page":"Metric manifold","title":"Manifolds.MetricManifold","text":"MetricManifold{M<:Manifold,G<:Metric} <: Manifold\n\nEquip a Manifold explicitly with a Metric G.\n\nFor a Metric Manifold, by default, assumes, that you implement the linear form from local_metric in order to evaluate the exponential map.\n\nIf the corresponding Metric G yields closed form formulae for e.g. the exponential map and this is implemented directly (without solving the ode), you can of course still implement that directly.\n\nConstructor\n\nMetricManifold(M, G)\n\nGenerate the Manifold M as a manifold with the Metric G.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/metric.html#Manifolds.RiemannianMetric","page":"Metric manifold","title":"Manifolds.RiemannianMetric","text":"RiemannianMetric <: Metric\n\nAbstract type for Riemannian metrics, a family of positive definite inner products. The positive definite property means that for v in T_x M, the inner product g(v v)  0 whenever v is not the zero vector.\n\n\n\n","category":"type"},{"location":"manifolds/metric.html#Implement-Different-Metrics-on-the-same-Manifold-1","page":"Metric manifold","title":"Implement Different Metrics on the same Manifold","text":"","category":"section"},{"location":"manifolds/metric.html#","page":"Metric manifold","title":"Metric manifold","text":"In order to distinguish different metrics on one manifold, one can introduce two Metrics and use this type to dispatch on the metric, see SymmetricPositiveDefinite. To avoid overhead, one Metric can then be marked as being the default, i.e. the one that is used, when no MetricManifold decorator is present. This avoids reimplementation of the first existing metric, access to the metric-dependent functions that were implemented using the undecorated manifold, as well as the transparent fallback of the corresponding MetricManifold with default metric to the undecorated implementations. This does not cause any runtime overhead. Introducing a default Metric serves a better readability of the code when working with different metrics.","category":"page"},{"location":"manifolds/metric.html#Implementation-of-Metrics-1","page":"Metric manifold","title":"Implementation of Metrics","text":"","category":"section"},{"location":"manifolds/metric.html#","page":"Metric manifold","title":"Metric manifold","text":"For the case that a local_metric is implemented as a bilinear form that is positive definite, the following further functions are provided, unless the corresponding Metric is marked as default â€“ then the fallbacks mentioned in the last section are used for e.g. the exp!onential map.","category":"page"},{"location":"manifolds/metric.html#","page":"Metric manifold","title":"Metric manifold","text":"Modules = [Manifolds, ManifoldsBase]\nPages = [\"manifolds/MetricManifold.jl\"]\nOrder = [:function]","category":"page"},{"location":"manifolds/metric.html#Base.exp-Tuple{MetricManifold,Vararg{Any,N} where N}","page":"Metric manifold","title":"Base.exp","text":"exp(N::MetricManifold{M,G}, x, v)\n\nCopute the exponential map on the Manifold M equipped with the Metric G.\n\nIf the metric was declared the default metric using is_default_metric, this method falls back to exp(M,x,v).\n\nOtherwise it numerically integrates the underlying ODE, see solve_exp_ode. Currently, the numerical integration is only accurate when using a single coordinate chart that covers the entire manifold. This excludes coordinates in an embedded space.\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.christoffel_symbols_first-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.christoffel_symbols_first","text":"christoffel_symbols_first(M::MetricManifold, x; backend=:default)\n\nCompute the Christoffel symbols of the first kind in local coordinates. The Christoffel symbols are (in Einstein summation convention)\n\nGamma_ijk = frac12 leftg_kji + g_ikj - g_ijkright\n\nwhere g_ijk=fracpartialpartial x^k g_ij is the coordinate derivative of the local representation of the metric tensor. The dimensions of the resulting multi-dimensional array are ordered (ijk).\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.christoffel_symbols_second-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.christoffel_symbols_second","text":"christoffel_symbols_second(M::MetricManifold, x; backend=:default)\n\nCompute the Christoffel symbols of the second kind in local coordinates. The Christoffel symbols are (in Einstein summation convention)\n\nGamma^l_ij = g^kl Gamma_ijk\n\nwhere Gamma_ijk are the Christoffel symbols of the first kind, and g^kl is the inverse of the local representation of the metric tensor. The dimensions of the resulting multi-dimensional array are ordered (lij).\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.christoffel_symbols_second_jacobian-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.christoffel_symbols_second_jacobian","text":"christoffel_symbols_second_jacobian(M::MetricManifold, x; backend = :default)\n\nGet partial derivatives of the Christoffel symbols of the second kind for manifold M at x with respect to the coordinates of x, fracpartialpartial x^l Gamma^k_ij = Gamma^k_ijl The dimensions of the resulting multi-dimensional array are ordered (ijkl).\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.det_local_metric-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.det_local_metric","text":"det_local_metric(M::MetricManifold, x)\n\nReturn the determinant of local matrix representation of the metric tensor g.\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.einstein_tensor-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.einstein_tensor","text":"einstein_tensor(M::MetricManifold, x; backend = :default)\n\nCompute the Einstein tensor of the manifold M at the point x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.flat-Tuple{MetricManifold,Vararg{Any,N} where N}","page":"Metric manifold","title":"Manifolds.flat","text":"flat(N::MetricManifold{M,G}, x, w::FVector{TangentSpaceType})\n\nCompute the musical isomorphism to transform the tangent vector w from the Manifold M equipped with Metric G to a cotangent by computing\n\nw^flat = G_xw\n\nwhere G_x is the local matrix representation of G, see local_metric\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.gaussian_curvature-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.gaussian_curvature","text":"gaussian_curvature(M::MetricManifold, x; backend = :default)\n\nCompute the Gaussian curvature of the manifold M at the point x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.inverse_local_metric-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.inverse_local_metric","text":"inverse_local_metric(M::MetricManifold, x)\n\nReturn the local matrix representation of the inverse metric (cometric) tensor, usually written g^ij.\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.is_default_metric-Tuple{Manifold,Metric}","page":"Metric manifold","title":"Manifolds.is_default_metric","text":"is_default_metric(M,G)\n\nIndicate whether the Metric G is the default metric for the Manifold M. This means that any occurence of MetricManifold(M,G) where typeof(is_default_metric(M,G)) = Val{true} falls back to just be called with M such that the Manifold M implicitly has this metric, for example if this was the first one implemented or is the one most commonly assumed to be used.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.is_default_metric-Union{Tuple{MMT}, Tuple{MMT}} where MMT<:MetricManifold","page":"Metric manifold","title":"Manifolds.is_default_metric","text":"is_default_metric(MM)\n\nIndicate whether the Metric MM.G is the default metric for the Manifold MM.M within the MetricManifold MM. This means that any occurence of MetricManifold(MM.M,MM.G) where typeof(is_default_metric(MM.M,MM.G)) = Val{true} falls back to just be called with MM.MM such that the Manifold MM.M implicitly has the metric MM.G, for example if this was the first one implemented or is the one most commonly assumed to be used.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.local_metric-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.local_metric","text":"local_metric(M::MetricManifold, x)\n\nReturn the local matrix representation at the point x of the metric tensor g on the Manifold M, usually written g_ij. The matrix has the property that g(v w)=v^T g_ij w = g_ij v^i w^j, where the latter expression uses Einstein summation convention.\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.local_metric_jacobian-Tuple{Any,Any}","page":"Metric manifold","title":"Manifolds.local_metric_jacobian","text":"local_metric_jacobian(M::MetricManifold, x; backend=:default)\n\nGet partial derivatives of the local metric of M at x with respect to the coordinates of x, fracpartialpartial x^k g_ij = g_ijk. The dimensions of the resulting multi-dimensional array are ordered (ijk).\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.log_local_metric_density-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.log_local_metric_density","text":"log_local_metric_density(M::MetricManifold, x)\n\nReturn the natural logarithm of the metric density rho of M at x, which is given by rho=log sqrtdet g_ij.\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.metric-Tuple{MetricManifold}","page":"Metric manifold","title":"Manifolds.metric","text":"metric(M::MetricManifold)\n\nGet the metric g of the manifold M.\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.ricci_curvature-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.ricci_curvature","text":"ricci_curvature(M::MetricManifold, x; backend = :default)\n\nCompute the Ricci scalar curvature of the manifold M at the point x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.ricci_tensor-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.ricci_tensor","text":"ricci_tensor(M::MetricManifold, x; backend = :default)\n\nCompute the Ricci tensor, also known as the Ricci curvature tensor, of the manifold M at the point x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.riemann_tensor-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.riemann_tensor","text":"riemann_tensor(M::MetricManifold, x)\n\nCompute the Riemann tensor R^l_ijk, also known as the Riemann curvature tensor, at the point x. The dimensions of the resulting multi-dimensional array are ordered (lijk).\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.sharp-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.sharp","text":"sharp(N::MetricManifold{M,G}, x, w::FVector{CotangentSpaceType})\n\nCompute the musical isomorphism to transform the cotangent vector w from the Manifold M equipped with Metric G to a tangent by computing\n\nw^sharp = G_x^-1w\n\nwhere G_x is the local matrix representation of G, i.e. one employs inverse_local_metric here to obtain G_x^-1.\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#ManifoldsBase.inner-Union{Tuple{MMT}, Tuple{MMT,Any,Any,Any}} where MMT<:MetricManifold","page":"Metric manifold","title":"ManifoldsBase.inner","text":"inner(N::MetricManifold{M,G}, x, v, w)\n\nCompute the inner product of v, w from the tangent space at x on the Manifold M using the Metric G. If G is the default metric (see is_default_metric) this is done using log(M, x, v, w), otherwise the local_metric(M, x) is employed as\n\ng_x(vw) = langle v G_x wrangle\n\nwhere G_x is the local matrix representation of the Metric G.\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.solve_exp_ode-NTuple{4,Any}","page":"Metric manifold","title":"Manifolds.solve_exp_ode","text":"solve_exp_ode(\n    M::MetricManifold,\n    x,\n    v,\n    tspan;\n    backend = :default,\n    solver = AutoVern9(Rodas5()),\n    kwargs...,\n)\n\nApproximate the exponential map on the manifold over the provided timespan assuming the Levi-Civita connection by solving the ordinary differential equation\n\nfracd^2dt^2 x^k + Gamma^k_ij fracddt x_i fracddt x_j = 0\n\nwhere Gamma^k_ij are the Christoffel symbols of the second kind, and the Einstein summation convention is assumed. The arguments tspan and solver follow the OrdinaryDiffEq conventions. kwargs... specify keyword arguments that will be passed to OrdinaryDiffEq.solve.\n\nCurrently, the numerical integration is only accurate when using a single coordinate chart that covers the entire manifold. This excludes coordinates in an embedded space.\n\nnote: Note\nThis function only works for Julia 1.1 or greater, when OrdinaryDiffEq.jl is loaded withusing OrdinaryDiffEq\n\n\n\n","category":"method"},{"location":"manifolds/array.html#Array-manifold-1","page":"Array manifold","title":"Array manifold","text":"","category":"section"},{"location":"manifolds/array.html#","page":"Array manifold","title":"Array manifold","text":"Modules = [ManifoldsBase]\nPages = [\"ArrayManifold.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/array.html#ManifoldsBase.ArrayCoTVector","page":"Array manifold","title":"ManifoldsBase.ArrayCoTVector","text":"ArrayCoTVector <: CoTVector\n\nRepresent a cotangent vector to a point on an ArrayManifold, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from ArrayMPoints and ArrayTVectors.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/array.html#ManifoldsBase.ArrayMPoint","page":"Array manifold","title":"ManifoldsBase.ArrayMPoint","text":"ArrayMPoint <: MPoint\n\nRepresent a point on an ArrayManifold, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from ArrayTVectors and ArrayCoTVectors.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/array.html#ManifoldsBase.ArrayManifold","page":"Array manifold","title":"ManifoldsBase.ArrayManifold","text":"ArrayManifold{M<:Manifold} <: Manifold\n\nA manifold to encapsulate manifolds working on array representations of MPoints and TVectors in a transparent way, such that for these manifolds it's not necessary to introduce explicit types for the points and tangent vectors, but they are encapsulated/stripped automatically when needed.\n\nThis manifold is a decorator for a manifold, i.e. it decorates a manifold M with types points, vectors, and covectors.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/array.html#ManifoldsBase.ArrayTVector","page":"Array manifold","title":"ManifoldsBase.ArrayTVector","text":"ArrayTVector <: TVector\n\nRepresent a tangent vector to a point on an ArrayManifold, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from ArrayMPoints and ArrayCoTVectors.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/array.html#ManifoldsBase.array_value-Tuple{AbstractArray}","page":"Array manifold","title":"ManifoldsBase.array_value","text":"array_value(x)\n\nReturn the internal array value of a ArrayMPoint, ArrayTVector, or ArrayCoTVector if the value x is encapsulated as such. Return x if it is already an array.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetric.html#Symmetric-matrices-1","page":"Symmetric matrices","title":"Symmetric matrices","text":"","category":"section"},{"location":"manifolds/symmetric.html#","page":"Symmetric matrices","title":"Symmetric matrices","text":"Modules = [Manifolds]\nPages = [\"manifolds/Symmetric.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/symmetric.html#Manifolds.SymmetricMatrices","page":"Symmetric matrices","title":"Manifolds.SymmetricMatrices","text":"SymmetricMatrices{n,F} <: Manifold\n\nThe Manifold $ \\operatorname{Sym} (n)$ consisting of the real- or complex-valued symmetric matrices of size $ n\\times n$, i.e. the set\n\noperatornameSym(n) = biglA in mathbb F^ntimes n big A^mathrmH = A bigr\n\nwhere cdot^mathrmH denotes the hermitian, i.e. complex conjugate transposed and the field mathbb F in  mathbb R mathbb C is set by the AbstractNumbers F.\n\nThough it is slighty redundant, usually the matrices are safed as ntimes n arrays.\n\nConstructor\n\nSymmetricMatrices(n::Int, F::AbstractNumbers=â„)\n\nGenerate the manifold of ntimes n symmetric metrices.\n\n\n\n","category":"type"},{"location":"manifolds/symmetric.html#Base.exp-Tuple{SymmetricMatrices,Vararg{Any,N} where N}","page":"Symmetric matrices","title":"Base.exp","text":"exp(M::SymmetricMatrices, x, v)\n\nCompute the exponential map eminating from x in tangent direction v on the SymmetricMatrices M, which reads\n\nexp_xv = x + v\n\n\n\n","category":"method"},{"location":"manifolds/symmetric.html#Base.log-Tuple{SymmetricMatrices,Vararg{Any,N} where N}","page":"Symmetric matrices","title":"Base.log","text":"log(M::SymmetricMatrices, x, y)\n\nCompute the logarithmic map from x to y on the SymmetricMatrices M, which reads\n\nlog_xy = y-x\n\n\n\n","category":"method"},{"location":"manifolds/symmetric.html#LinearAlgebra.norm-Tuple{SymmetricMatrices,Any,Any}","page":"Symmetric matrices","title":"LinearAlgebra.norm","text":"norm(M::SymmetricMatrices, x, v)\n\nCompute the norm of the tangent vector v from the tangent space at x on the SymmetricMatrices M, which is the norm from the embedding, i.e.\n\nlVert v rVert_x = lVert v rVert_2\n\n\n\n","category":"method"},{"location":"manifolds/symmetric.html#Manifolds.flat-Tuple{SymmetricMatrices,Vararg{Any,N} where N}","page":"Symmetric matrices","title":"Manifolds.flat","text":"flat(M::SymmetricMatrices, x, w::FVector{TangentSpaceType})\n\nCompute the flat isomorphism of the SymmetricMatrices M on the manifold point x and tangent vector w.\n\nSince M is already a vector space over mathbb R, this returns just the vector w.\n\n\n\n","category":"method"},{"location":"manifolds/symmetric.html#Manifolds.sharp-Tuple{SymmetricMatrices,Vararg{Any,N} where N}","page":"Symmetric matrices","title":"Manifolds.sharp","text":"sharp(M::SymmetricMatrices, x, w::FVector{CotangentSpaceType})\n\nCompute the sharp isomorphism of the SymmetricMatrices M on the manifold point x and cotangent vector w.\n\nSince M is already a vector space over mathbb R, this returns just the vector w.\n\n\n\n","category":"method"},{"location":"manifolds/symmetric.html#ManifoldsBase.distance-Tuple{SymmetricMatrices,Any,Any}","page":"Symmetric matrices","title":"ManifoldsBase.distance","text":"distance(M::SymmetricMatrices, x, y)\n\nCompute distance using the inherited metric, i.e. taking the Frobenius-norm of the difference.\n\n\n\n","category":"method"},{"location":"manifolds/symmetric.html#ManifoldsBase.inner-Tuple{SymmetricMatrices,Any,Any,Any}","page":"Symmetric matrices","title":"ManifoldsBase.inner","text":"inner(M::SymmetricMatrices, x, w, v)\n\nCompute the inner product of the two tangent vectors w, v from the tangent space at x on the SymmetricMatrices M using the restriction of the metric from the embedding, i.e.\n\n(vw)_x = operatornametr(v^mathrmHw)\n\nwhere cdot^mathrmH denotes the hermitian, i.e. complex conjugate transposed.\n\n\n\n","category":"method"},{"location":"manifolds/symmetric.html#ManifoldsBase.manifold_dimension-Union{Tuple{SymmetricMatrices{N,ð”½}}, Tuple{ð”½}, Tuple{N}} where ð”½ where N","page":"Symmetric matrices","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::SymmetricMatrices{n,ð”½})\n\nReturn the dimension of the SymmetricMatrices matrix M over the number system ð”½, i.e.\n\ndim operatornameSym(nð”½) = fracn(n+1)2 dim_â„ ð”½\n\nwhere dim_â„ ð”½ is the real_dimension of ð”½.\n\n\n\n","category":"method"},{"location":"manifolds/symmetric.html#ManifoldsBase.project_point-Tuple{SymmetricMatrices,Vararg{Any,N} where N}","page":"Symmetric matrices","title":"ManifoldsBase.project_point","text":"project_point(M::SymmetricMatrices,x)\n\nProjects x from the embedding onto the SymmetricMatrices M, i.e.\n\noperatornameproj_operatornameSym(n)(x) = frac12 bigl( x + x^mathrmH bigr)\n\nwhere cdot^mathrmH denotes the hermitian, i.e. complex conjugate transposed.\n\n\n\n","category":"method"},{"location":"manifolds/symmetric.html#ManifoldsBase.project_tangent-Tuple{SymmetricMatrices,Vararg{Any,N} where N}","page":"Symmetric matrices","title":"ManifoldsBase.project_tangent","text":"project_tangent(M::SymmetricMatrices, x, v)\n\nProject the matrix v onto the tangent space at x on the SymmetricMatrices M,\n\noperatornameproj_x(v) = frac12 bigl( v + v^mathrmH bigr)\n\nwhere cdot^mathrmH denotes the hermitian, i.e. complex conjugate transposed.\n\n\n\n","category":"method"},{"location":"manifolds/symmetric.html#ManifoldsBase.representation_size-Union{Tuple{SymmetricMatrices{N,F} where F}, Tuple{N}} where N","page":"Symmetric matrices","title":"ManifoldsBase.representation_size","text":"representation_size(M::SymmetricMatrices)\n\nReturns the size points on the SymmetricMatrices M are represented as, i.e. for the ntimes n it's (n,n).\n\n\n\n","category":"method"},{"location":"manifolds/symmetric.html#ManifoldsBase.vector_transport_to-Tuple{SymmetricMatrices,Vararg{Any,N} where N}","page":"Symmetric matrices","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::SymmetricMatrices, x, v, y, ::ParallelTransport)\n\nCompute the parallel vector_transport_to of v from the tangent space at x on the SymmetricMatrices M to y. Since the metric is inherited from the embedding space, this is just the identity, i.e.\n\nP_ygets x(v) = v\n\n\n\n","category":"method"},{"location":"manifolds/symmetric.html#ManifoldsBase.zero_tangent_vector-Tuple{SymmetricMatrices,Vararg{Any,N} where N}","page":"Symmetric matrices","title":"ManifoldsBase.zero_tangent_vector","text":"zero_tangent_vector(M, x)\n\nReturn the zero tangent vector for the tangent space at x on the SymmetricMatrices M, i.e. the zero matrix.\n\n\n\n","category":"method"},{"location":"manifolds/symmetric.html#ManifoldsBase.check_manifold_point-Union{Tuple{F}, Tuple{n}, Tuple{SymmetricMatrices{n,F},Any}} where F where n","page":"Symmetric matrices","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::SymmetricMatrices{n,F}, x; kwargs...)\n\nCheck whether x is a valid manifold point on the SymmetricMatrices M, i.e. whether x is a symmetric matrix of size (n,n) with values from the corresponding AbstractNumbers F.\n\nThe tolerance for the symmetry of x can be set using kwargs....\n\n\n\n","category":"method"},{"location":"manifolds/symmetric.html#ManifoldsBase.check_tangent_vector-Union{Tuple{F}, Tuple{n}, Tuple{SymmetricMatrices{n,F},Any,Any}} where F where n","page":"Symmetric matrices","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::SymmetricMatrices{n,F}, x, v; kwargs... )\n\nCheck whether v is a tangent vector to manifold point x on the SymmetricMatrices M, i.e. v has to be a symmetric matrix of dimension (n,n) and its values have to be from the correct AbstractNumbers.\n\nThe tolerance for the symmetry of x and v can be set using kwargs....\n\n\n\n\n\n","category":"method"},{"location":"distributions.html#Distributions-1","page":"Distributions","title":"Distributions","text":"","category":"section"},{"location":"distributions.html#","page":"Distributions","title":"Distributions","text":"Following functions and types provide support for manifold-valued and tangent space-valued distributions.","category":"page"},{"location":"distributions.html#","page":"Distributions","title":"Distributions","text":"Modules = [Manifolds]\nPages = [\"distributions.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"distributions.html#Manifolds.FVectorDistribution","page":"Distributions","title":"Manifolds.FVectorDistribution","text":"FVectorDistribution{TSpace<:VectorBundleFibers, T}\n\nAn abstract distribution for vector bundle fiber-valued distributions (values from a fiber of a vector bundle at point x from the given manifold). For example used for tangent vector-valued distributions.\n\n\n\n\n\n","category":"type"},{"location":"distributions.html#Manifolds.FVectorSupport","page":"Distributions","title":"Manifolds.FVectorSupport","text":"FVectorSupport(space::Manifold, VectorBundleFibers)\n\nValue support for vector bundle fiber-valued distributions (values from a fiber of a vector bundle at point x from the given manifold). For example used for tangent vector-valued distributions.\n\n\n\n\n\n","category":"type"},{"location":"distributions.html#Manifolds.FVectorvariate","page":"Distributions","title":"Manifolds.FVectorvariate","text":"FVectorvariate\n\nStructure that subtypes VariateForm, indicating that a single sample is a vector from a fiber of a vector bundle.\n\n\n\n\n\n","category":"type"},{"location":"distributions.html#Manifolds.MPointDistribution","page":"Distributions","title":"Manifolds.MPointDistribution","text":"MPointDistribution{TM<:Manifold}\n\nAn abstract distribution for points on manifold of type TM.\n\n\n\n\n\n","category":"type"},{"location":"distributions.html#Manifolds.MPointSupport","page":"Distributions","title":"Manifolds.MPointSupport","text":"MPointSupport(M::Manifold)\n\nValue support for manifold-valued distributions (values from given Manifold M).\n\n\n\n\n\n","category":"type"},{"location":"distributions.html#Manifolds.MPointvariate","page":"Distributions","title":"Manifolds.MPointvariate","text":"MPointvariate\n\nStructure that subtypes VariateForm, indicating that a single sample is a point on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"distributions.html#Distributions.support-Union{Tuple{T}, Tuple{T}} where T<:Manifolds.FVectorDistribution","page":"Distributions","title":"Distributions.support","text":"support(d::FVectorDistribution)\n\nGet the object of type FVectorSupport for the distribution d.\n\n\n\n\n\n","category":"method"},{"location":"distributions.html#","page":"Distributions","title":"Distributions","text":"Manifolds.ProjectedPointDistribution\nManifolds.ProjectedFVectorDistribution","category":"page"},{"location":"distributions.html#Manifolds.ProjectedPointDistribution","page":"Distributions","title":"Manifolds.ProjectedPointDistribution","text":"ProjectedPointDistribution(m::Manifold, d, proj!, x)\n\nGenerates a random point in ambient space of m and projects it to m using function proj!. Generated arrays are of type TResult, which can be specified by providing the x argument.\n\n\n\n\n\n","category":"type"},{"location":"distributions.html#Manifolds.ProjectedFVectorDistribution","page":"Distributions","title":"Manifolds.ProjectedFVectorDistribution","text":"ProjectedFVectorDistribution(type::VectorBundleFibers, x, d, project_vector!)\n\nGenerates a random vector from ambient space of manifold type.manifold at point x and projects it to vector space of type type using function project_vector!, see project_vector for documentation. Generated arrays are of type TResult.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/grassmann.html#Grassmann-manifold-1","page":"Grassmannian","title":"Grassmann manifold","text":"","category":"section"},{"location":"manifolds/grassmann.html#","page":"Grassmannian","title":"Grassmannian","text":"Modules = [Manifolds]\nPages = [\"manifolds/Grassmann.jl\"]\nOrder = [:type,:function]","category":"page"},{"location":"manifolds/grassmann.html#Manifolds.Grassmann","page":"Grassmannian","title":"Manifolds.Grassmann","text":"Grassmann{n,k,F} <: Manifold\n\nThe Grassmann manifold operatornameGr(nk) consists of all subspaces spanned by k linear independent vectors mathbb F^n, where mathbb F in mathbb R mathbb C is either the real- (or complex-) valued vectors. This yields all k-dimensional subspaces of mathbb R^n for the real-valued case and all 2k-dimensional subspaces of mathbb C^n for the second.\n\nThe manifold can be represented as\n\noperatornameGr(nk) coloneqq bigl operatornamespan(x)\n x in mathbb F^ntimes k barx^mathrmTx = I_k\n\nwhere barcdot^mathrmT denotes the complex conjugate transpose and I_k is the ktimes k identity matrix. This means, that the columns of x form an orthonormal basis of the subspace, that is a point on operatornameGr(nk), and hence the subspace can actually be represented by a whole equivalence class of representers. Another interpretation is, that\n\noperatornameGr(nk) = operatornameSt(nk)  operatornameO(k)\n\ni.e the Grassmann manifold is the quotient of the Stiefel manifold and the orthogonal group operatornameO(k) of orthogonal ktimes k matrices.\n\nThe tangent space at a point (subspace) x is given by\n\nT_xmathrmGr(nk) = bigl\nv in mathbbF^ntimes k \nbar v^mathrmTx + bar x^mathrmTv = 0_k bigr\n\nwhere 0_k denotes the ktimes k zero matrix.\n\nNote that a point xin operatornameGr(nk) might be represented by different matrices (i.e. matrices with orthonormal column vectors that span the same subspace). Different representations of x also lead to different representation matrices for the tangent space T_xmathrmGr(nk)\n\nThe manifold is named after Hermann G. GraÃŸmann (1809-1877).\n\nConstructor\n\nGrassmann(n,k,F=â„)\n\nGenerate the Grassmann manifold operatornameGr(nk), where the real-valued case mathbb F = mathbb R is the default.\n\n\n\n","category":"type"},{"location":"manifolds/grassmann.html#Base.exp-Tuple{Grassmann,Vararg{Any,N} where N}","page":"Grassmannian","title":"Base.exp","text":"exp(M::Grassmann, x, v)\n\nCompute the exponential map on the Grassmann M= mathrmGr(nk) starting in x with tangent vector (direction) v. Let v = USV denote the SVD decomposition of v. Then the exponential map is written using\n\nz = x Vcos(S)V^mathrmH + Usin(S)V^mathrmH\n\nwhere cdot^mathrmH denotes the complex conjugate transposed or Hermitian. The cosine and sine are applied element wise to the diagonal entries of S. A final QR decomposition z=QR is performed for numerical stability reasons, yielding the result as\n\nexp_x v = Q\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#Base.log-Tuple{Grassmann,Vararg{Any,N} where N}","page":"Grassmannian","title":"Base.log","text":"log(M::Grassmann, x, y)\n\nCompute the logarithmic map on the Grassmann M$ = \\mathcal M=\\mathrm{Gr}(n,k)$, i.e. the tangent vector v whose corresponding geodesic starting from x reaches y after time 1 on M. The formula reads\n\nlog_xy = Vcdot operatornameatan(S) cdot U^mathrmH\n\nwhere cdot^mathrmH denotes the complex conjugate transposed or Hermitian. U and V are the unitary matrices, and S is a diagonal matrix containing the singular values of the SVD-decomposition of\n\nUSV = (y^mathrmHx)^-1 ( y^mathrmH - y^mathrmHxx^mathrmH )\n\nIn this formula the operatornameatan is meant elementwise.\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.distance-Tuple{Grassmann,Any,Any}","page":"Grassmannian","title":"ManifoldsBase.distance","text":"distance(M::Grassmann, x, y)\n\nCompute the Riemannian distance on Grassmann manifold M= mathrmGr(nk).\n\nLet USV = x^mathrmHy denote the SVD decomposition of x^mathrmHy, where cdot^mathrmH denotes the complex conjugate transposed or Hermitian. Then the distance is given by\n\nd_mathrmGR(nk)(xy) = operatornamenorm(operatornameRe(b))\n\nwhere\n\nb_i=begincases 0  textif  S_i geq 1 operatornameacos(S_i)   textif  S_i1 endcases\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.inner-Tuple{Grassmann,Any,Any,Any}","page":"Grassmannian","title":"ManifoldsBase.inner","text":"inner(M::Grassmann, x, v, w)\n\nCompute the inner product for two tangent vectors v, w from the tangent space of x on the Grassmann manifold M. The formula reads\n\ng_x(vw) = operatornametrace(v^mathrmHw)\n\nwhere cdot^mathrmH denotes the complex conjugate transposed or Hermitian.\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.inverse_retract-Tuple{Grassmann,Any,Any,PolarInverseRetraction}","page":"Grassmannian","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::Grassmann, x, y, ::PolarInverseRetraction)\n\nCompute the inverse retraction for the PolarRetraction, on the Grassmann, i.e.,\n\noperatornameretr_x^-1y = y*(x^mathrmHy)^-1 - x\n\nwhere cdot^mathrmH denotes the complex conjugate transposed or Hermitian.\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.inverse_retract-Tuple{Grassmann,Any,Any,QRInverseRetraction}","page":"Grassmannian","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M, x, y, ::QRInverseRetraction)\n\nCompute the inverse retraction valid of the QRRetraction\n\noperatornameretr_x^-1y = y*(x^mathrmHy)^-1 - x\n\nwhere cdot^mathrmH denotes the complex conjugate transposed or Hermitian.\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.manifold_dimension-Union{Tuple{Grassmann{n,k,ð”½}}, Tuple{ð”½}, Tuple{k}, Tuple{n}} where ð”½ where k where n","page":"Grassmannian","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::Grassmann)\n\nReturn the dimension of the Grassmann(n,k,ð”½) manifold M, i.e.\n\ndim operatornameGr(nk) = k(n-k) dim_â„ ð”½\n\nwhere dim_â„ ð”½ is the real_dimension of ð”½.\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.project_tangent-Tuple{Grassmann,Vararg{Any,N} where N}","page":"Grassmannian","title":"ManifoldsBase.project_tangent","text":"project_tangent(M::Grassmann, x, w)\n\nProject the n-by-k w onto the tangent space of x on the Grassmann M, which is computed by\n\noperatornameproj_x(w) = w - xx^mathrmHw\n\nwhere cdot^mathrmH denotes the complex conjugate transposed or Hermitian.\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.representation_size-Union{Tuple{Grassmann{n,k,F} where F}, Tuple{k}, Tuple{n}} where k where n","page":"Grassmannian","title":"ManifoldsBase.representation_size","text":"representation_size(M::Grassmann{n,k,F})\n\nReturn the represenation size or matrix dimension of a point on the Grassmann M, i.e. (nk) for both the real-valued and the complex value case.\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.retract-Tuple{Grassmann,Vararg{Any,N} where N}","page":"Grassmannian","title":"ManifoldsBase.retract","text":"retract(M::Grassmann, x, v, ::PolarRetraction)\n\nCompute the SVD-based retraction PolarRetraction on the Grassmann M. With USV = x + v the retraction reads\n\noperatornameretr_x v = UV^mathrmH\n\nwhere cdot^mathrmH denotes the complex conjugate transposed or Hermitian.\n\nretract(M::Grassmann, x, v, ::QRRetraction )\n\nCompute the QR-based retraction QRRetraction on the Grassmann M. With QR = x + v the retraction reads\n\noperatornameretr_xv = QD\n\nwhere D is a mtimes n matrix with\n\nD = operatornamediag( operatornamesgn(R_ii+05)_i=1^n )\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.zero_tangent_vector-Tuple{Grassmann,Vararg{Any,N} where N}","page":"Grassmannian","title":"ManifoldsBase.zero_tangent_vector","text":"zero_tangent_vector(M::Grassmann, x)\n\nReturn the zero tangent vector from the tangent space at x on the Grassmann M, which is given by a zero matrix the same size as x.\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#Statistics.mean-Tuple{Grassmann{n,k,â„} where k where n,Vararg{Any,N} where N}","page":"Grassmannian","title":"Statistics.mean","text":"mean(\n    M::Grassmann,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method = GeodesicInterpolationWithinRadius(Ï€/4);\n    kwargs...,\n)\n\nCompute the Riemannian mean of x using GeodesicInterpolationWithinRadius.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.check_manifold_point-Union{Tuple{F}, Tuple{k}, Tuple{n}, Tuple{Grassmann{n,k,F},Any}} where F where k where n","page":"Grassmannian","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::Grassmann{n,k,F}, x)\n\nCheck whether x is representing a point on the Grassmann M, i.e. its a n-by-k matrix of unitary column vectors and of correct eltype with respect to F.\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.check_tangent_vector-Union{Tuple{F}, Tuple{k}, Tuple{n}, Tuple{Grassmann{n,k,F},Any,Any}} where F where k where n","page":"Grassmannian","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::Grassmann{n,k,F}, x, v)\n\nCheck whether v is a tangent vector in the tangent space of x on the Grassmann M, i.e. that v is of size and type as well as that\n\n    x^mathrmHv + v^mathrmHx = 0_k\n\nwhere cdot^mathrmH denotes the complex conjugate transpose or Hermitian and 0_k denotes the ktimes k zero natrix.\n\n\n\n","category":"method"},{"location":"lib/autodiff.html#Automatic-differentiation-1","page":"Automatic differentiation","title":"Automatic differentiation","text":"","category":"section"},{"location":"lib/autodiff.html#","page":"Automatic differentiation","title":"Automatic differentiation","text":"Documentation for Manifolds.jl's methods and types for automatic differentiation.","category":"page"},{"location":"lib/autodiff.html#","page":"Automatic differentiation","title":"Automatic differentiation","text":"Manifolds.adbackend\nManifolds.adbackend!\nManifolds.adbackends","category":"page"},{"location":"lib/autodiff.html#Manifolds.adbackend","page":"Automatic differentiation","title":"Manifolds.adbackend","text":"adbackend(backend::Symbol = :default) -> Symbol\n\nCheck if autodiff backend is valid (see adbackends) and return formatted. Note that backend=:default returns the current backend.\n\n\n\n\n\n","category":"function"},{"location":"lib/autodiff.html#Manifolds.adbackend!","page":"Automatic differentiation","title":"Manifolds.adbackend!","text":"adbackend!(backend::Symbol)\n\nSet current backend for autodiff to backend.\n\n\n\n\n\n","category":"function"},{"location":"lib/autodiff.html#Manifolds.adbackends","page":"Automatic differentiation","title":"Manifolds.adbackends","text":"adbackends() -> Vector{Symbol}\n\nGet vector of currently valid AD backends.\n\n\n\n\n\n","category":"function"},{"location":"lib/public.html#Public-documentation-1","page":"Public","title":"Public documentation","text":"","category":"section"},{"location":"lib/public.html#","page":"Public","title":"Public","text":"Documentation for Manifolds.jl's public interface.","category":"page"},{"location":"lib/public.html#","page":"Public","title":"Public","text":"allocate\nManifolds.ShapeSpecification\nsubmanifold_component\nsubmanifold_components\nManifolds.ProductArray\nProductRepr\nManifolds.prod_point\nManifolds.StaticReshaper\nManifolds.ArrayReshaper\nManifolds.make_reshape","category":"page"},{"location":"lib/public.html#ManifoldsBase.allocate","page":"Public","title":"ManifoldsBase.allocate","text":"allocate(a)\nallocate(a, dims::Int...)\nallocate(a, dims::Tuple)\nallocate(a, T::Type)\nallocate(a, T::Type, dims::Int...)\nallocate(a, T::Type, dims::Tuple)\n\nAllocate an object similar to a. It is similar to function similar, although instead of working only on the outermost layer of a nested structure, it maps recursively through outer layers and calls similar on the innermost array-like object only. Type T is the new number element type number_eltype, if it is not given the element type of a is retained. The dims argument can be given for non-nested allocation and is forwarded to the function similar.\n\n\n\n\n\n","category":"function"},{"location":"lib/public.html#Manifolds.ShapeSpecification","page":"Public","title":"Manifolds.ShapeSpecification","text":"ShapeSpecification(reshapers, manifolds::Manifold...)\n\nA structure for specifying array size and offset information for linear storage of points and tangent vectors on the product manifold of manifolds.\n\nThe first argument, reshapers, indicates how a view representing a point in the ProductArray will be reshaped. It can either be an object of type AbstractReshaper that will be applied to all views or a tuple of such objects that will be applied to subsequent manifolds.\n\nTwo main reshaping methods are provided by types StaticReshaper that is faster for manifolds represented by small arrays (up to about 100 elements) and ArrayReshaper that is faster for larger arrays.\n\nFor example, consider the shape specification for the product of a sphere and group of rotations:\n\njulia> M1 = Sphere(2)\nSphere{2}()\n\njulia> M2 = Manifolds.Rotations(2)\nManifolds.Rotations{2}()\n\njulia> reshaper = Manifolds.StaticReshaper()\nManifolds.StaticReshaper()\n\njulia> shape = Manifolds.ShapeSpecification(reshaper, M1, M2)\nManifolds.ShapeSpecification{(1:3, 4:7),Tuple{Tuple{3},Tuple{2,2}},\n  Tuple{Manifolds.StaticReshaper,Manifolds.StaticReshaper}}(\n  (Manifolds.StaticReshaper(), Manifolds.StaticReshaper()))\n\nTRanges contains ranges in the linear storage that correspond to a specific manifold. Sphere(2) needs three numbers and is first, so it is allocated the first three elements of the linear storage (1:3). Rotations(2) needs four numbers and is second, so the next four numbers are allocated to it (4:7). TSizes describe how the linear storage must be reshaped to correctly represent points. In this case, Sphere(2) expects a three-element vector, so the corresponding size is Tuple{3}. On the other hand, Rotations(2) expects two-by-two matrices, so its size specification is Tuple{2,2}.\n\n\n\n\n\n","category":"type"},{"location":"lib/public.html#Manifolds.submanifold_component","page":"Public","title":"Manifolds.submanifold_component","text":"submanifold_component(M::Manifold, x, i::Integer)\nsubmanifold_component(M::Manifold, x, ::Val(i)) where {i}\nsubmanifold_component(x, i::Integer)\nsubmanifold_component(x, ::Val(i)) where {i}\n\nProject the product array x on M to its ith component. A new array is returned.\n\n\n\n","category":"function"},{"location":"lib/public.html#Manifolds.submanifold_components","page":"Public","title":"Manifolds.submanifold_components","text":"submanifold_components(M::Manifold, x)\nsubmanifold_components(x)\n\nGet the projected components of x on the submanifolds of M.\n\n\n\n","category":"function"},{"location":"lib/public.html#Manifolds.ProductArray","page":"Public","title":"Manifolds.ProductArray","text":"ProductArray(shape::ShapeSpecification, data)\n\nAn array-based representation for points and tangent vectors on the product manifold. data contains underlying representation of points arranged according to TRanges and TSizes from shape. Internal views for each specific sub-point are created and stored in parts.\n\n\n\n\n\n","category":"type"},{"location":"lib/public.html#Manifolds.ProductRepr","page":"Public","title":"Manifolds.ProductRepr","text":"ProductRepr(parts)\n\nA more general but slower representation of points and tangent vectors on a product manifold.\n\nExample:\n\nA product point on a product manifold Sphere(2) Ã— Euclidean(2) might be created as\n\nProductRepr([1.0, 0.0, 0.0], [2.0, 3.0])\n\nwhere [1.0, 0.0, 0.0] is the part corresponding to the sphere factor and [2.0, 3.0] is the part corresponding to the euclidean manifold.\n\n\n\n\n\n","category":"type"},{"location":"lib/public.html#Manifolds.prod_point","page":"Public","title":"Manifolds.prod_point","text":"prod_point(M::ShapeSpecification, pts...)\n\nConstruct a product point from product manifold M based on point pts represented by ProductArray.\n\nExample\n\nTo construct a point on the product manifold S^2 times mathbbR^2 from points on the sphere and in the euclidean space represented by, respectively, [1.0, 0.0, 0.0] and [-3.0, 2.0] you need to construct shape specification first. It describes how linear storage of ProductArray corresponds to array representations expected by Sphere(2) and Euclidean(2).\n\nM1 = Sphere(2)\nM2 = Euclidean(2)\nreshaper = Manifolds.StaticReshaper()\nMshape = Manifolds.ShapeSpecification(reshaper, M1, M2)\n\nNext, the desired point on the product manifold can be obtained by calling Manifolds.prod_point(Mshape, [1.0, 0.0, 0.0], [-3.0, 2.0]).\n\n\n\n","category":"function"},{"location":"lib/public.html#Manifolds.StaticReshaper","page":"Public","title":"Manifolds.StaticReshaper","text":"StaticReshaper()\n\nReshaper that constructs SizedAbstractArray.\n\n\n\n\n\n","category":"type"},{"location":"lib/public.html#Manifolds.ArrayReshaper","page":"Public","title":"Manifolds.ArrayReshaper","text":"ArrayReshaper()\n\nReshaper that constructs Base.ReshapedArray.\n\n\n\n\n\n","category":"type"},{"location":"lib/public.html#Manifolds.make_reshape","page":"Public","title":"Manifolds.make_reshape","text":"make_reshape(reshaper::AbstractReshaper, ::Type{Size}, data) where Size\n\nReshape array data to size Size using method provided by reshaper.\n\n\n\n\n\n","category":"function"},{"location":"manifolds/sphere.html#Sphere-1","page":"Sphere","title":"Sphere","text":"","category":"section"},{"location":"manifolds/sphere.html#","page":"Sphere","title":"Sphere","text":"Modules = [Manifolds]\nPages = [\"manifolds/Sphere.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/sphere.html#Manifolds.Sphere","page":"Sphere","title":"Manifolds.Sphere","text":"Sphere{N} <: Manifold\n\nThe unit sphere manifold mathbb S^n represented by n+1-Tuples, i.e. in by vectors in mathbb R^n+1 of unit length\n\nConstructor\n\nSphere(n)\n\nGenerate the mathbb S^nsubset mathbb R^n+1\n\n\n\n","category":"type"},{"location":"manifolds/sphere.html#Base.exp-Tuple{Sphere,Vararg{Any,N} where N}","page":"Sphere","title":"Base.exp","text":"exp(M::Sphere, x, v)\n\nCompute the exponential map from x into the tangent direction v on the Sphere M by following the great arc eminating from x in direction v along with length of v.\n\nexp_x v = cos(lVert v rVert_x)x + sin(lVert v rVert_x)fracvlVert v rVert_x\n\nwhere lVert v rVert_x is the norm on the Sphere M.\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#Base.log-Tuple{Sphere,Vararg{Any,N} where N}","page":"Sphere","title":"Base.log","text":"log(M::Sphere, x, y)\n\nCompute the logarithmic map on the Sphere M, i.e. the tangent vector, whose geodesic starting from x reaches y after time 1. The formula reads for xneq -y\n\nlog_x y = d_mathbb S^n(xy)\nfracy-langle xyrangle xlVert y-langle xyrangle x rVert_2\n\nand a deterministic choice from the set of tangent vectors is returned if x=-y, i.e. for opposite points.\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#LinearAlgebra.norm-Tuple{Sphere,Any,Any}","page":"Sphere","title":"LinearAlgebra.norm","text":"norm(M::Sphere, x, v)\n\nCompute the length of the tangent vector v from the tangent space at x on the Sphere M, which is the norm in the embedding, i.e.\n\nlVert v rVert_x = lVert v rVert_2\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#Manifolds.get_coordinates-Union{Tuple{N}, Tuple{Sphere{N},Any,Any,ArbitraryOrthonormalBasis}} where N","page":"Sphere","title":"Manifolds.get_coordinates","text":"get_coordinates(M::Sphere, x, v, B::ArbitraryOrthonormalBasis)\n\nRepresent the tangent vector v at point x from a sphere M in an orthonormal basis by rotating the vector v using rotation matrix 2fracx_p x_p^mathrmTx_p^mathrmT x_p - I where x_p = x + (1 0 dots 0).\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#Manifolds.normal_tvector_distribution-Tuple{Sphere,Any,Any}","page":"Sphere","title":"Manifolds.normal_tvector_distribution","text":"normal_tvector_distribution(S::Sphere, x, Ïƒ)\n\nNormal distribution in ambient space with standard deviation Ïƒ projected to tangent space at x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.distance-Tuple{Sphere,Any,Any}","page":"Sphere","title":"ManifoldsBase.distance","text":"distance(M::Sphere, x, y)\n\nCompute the geodesic distance betweeen x and y on the Sphere M. The formula is given by the (shorter) great arc length on the (or a) great circle both x and y lie on.\n\nd_mathbb S^n(xy) = operatornameacos(langle x yrangle)\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.injectivity_radius-Tuple{Sphere,Vararg{Any,N} where N}","page":"Sphere","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::Sphere[, x])\n\nReturn the injectivity radius for the Sphere M, which is globally pi.\n\ninjectivity_radius(M::Sphere, x, ::ProjectionRetraction)\n\nReturn the injectivity radius for the ProjectionRetraction on the Sphere, which is globally fracpi2.\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.inner-Tuple{Sphere,Any,Any,Any}","page":"Sphere","title":"ManifoldsBase.inner","text":"inner(S::Sphere, x, w, v)\n\nCompute the inner product of the two tangent vectors w,v from the tangent plane at x on the sphere S=mathbb S^n using the restriction of the metric from the embedding, i.e. $ (v,w)_x = v^\\mathrm{T}w $.\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.inverse_retract-Tuple{Sphere,Any,Any,ProjectionInverseRetraction}","page":"Sphere","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::Sphere, x, y, ::ProjectionInverseRetraction)\n\nCompute the inverse of the projection based retraction on the Sphere, i.e. rearranging x+v = ylVert x+d rVert_2 yields since langle xvrangle = 0 and when d_mathbb S^2(xy) leq fracpi2 that\n\noperatornameretr_x^-1(y) = fracylangle x y rangle - x\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.manifold_dimension-Union{Tuple{Sphere{N}}, Tuple{N}} where N","page":"Sphere","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(S::Sphere)\n\nReturn the dimension of the manifold mathbb S^n, i.e. n.\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.project_point-Tuple{Sphere,Vararg{Any,N} where N}","page":"Sphere","title":"ManifoldsBase.project_point","text":"project_point(M::Sphere, x)\n\nProject the point x from the embedding onto the Sphere M.\n\noperatornameproj_mathbb S^n(x) = fracxlVert x rVert_2\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.project_tangent-Tuple{Sphere,Vararg{Any,N} where N}","page":"Sphere","title":"ManifoldsBase.project_tangent","text":"project_tangent(M::Sphere, x, v)\n\nProject the point v onto the tangent space at x on the Sphere M.\n\noperatornameproj_x(v) = v - langle x v rangle_x\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.representation_size-Union{Tuple{Sphere{N}}, Tuple{N}} where N","page":"Sphere","title":"ManifoldsBase.representation_size","text":"representation_size(M::Sphere)\n\nReturn the size points on the Sphere M are represented as, i.e. for the n-dimensional Sphere it is vectors of size (n+1,).\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.retract-Tuple{Sphere,Any,Any,ProjectionRetraction}","page":"Sphere","title":"ManifoldsBase.retract","text":"retract(M::Sphere, x, y, ::ProjectionRetraction)\n\nCompute the retraction that is based on projection, i.e.\n\noperatornameretr_x(v) = fracx+vlVert x+v rVert_2\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.vector_transport_to-Tuple{Sphere,Any,Any,Any,ParallelTransport}","page":"Sphere","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::Sphere, x, v, y, ::ParallelTransport)\n\nCompute the ParallelTransport on the Sphere M, which is given by\n\nP_ygets x(v) = v - fraclangle log_xyvrangle_xd^2_mathbb S^n(xy)\nbigl(log_xy + log_yx bigr)\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.zero_tangent_vector-Tuple{Sphere,Vararg{Any,N} where N}","page":"Sphere","title":"ManifoldsBase.zero_tangent_vector","text":"zero_tangent_vector(M::Sphere, x)\n\nReturn the zero tangent vector from the tangent space at x on the Sphere M, which is the zero vector in the embedding.\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#Statistics.mean-Tuple{Sphere,Vararg{Any,N} where N}","page":"Sphere","title":"Statistics.mean","text":"mean(\n    S::Sphere,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method = GeodesicInterpolationWithinRadius(Ï€/2);\n    kwargs...,\n)\n\nCompute the Riemannian mean of x using GeodesicInterpolationWithinRadius.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#Manifolds.uniform_distribution-Tuple{Sphere,Any}","page":"Sphere","title":"Manifolds.uniform_distribution","text":"uniform_distribution(S::Sphere, x)\n\nUniform distribution on given sphere. Generated points will be of similar type to x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.check_manifold_point-Union{Tuple{N}, Tuple{Sphere{N},Any}} where N","page":"Sphere","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(S, x; kwargs...)\n\nCheck whether x is a valid point on the Sphere S, i.e. is a vector of length manifold_dimension(S)+1 (approximately) of unit length. The tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.check_tangent_vector-Union{Tuple{N}, Tuple{Sphere{N},Any,Any}} where N","page":"Sphere","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(S, x, v; kwargs... )\n\nCheck whether v is a tangent vector to x on the Sphere S, i.e. after check_manifold_point(S,x), v has to be of same dimension as x and orthogonal to x. The tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#Hyperbolic-space-1","page":"Hyperbolic space","title":"Hyperbolic space","text":"","category":"section"},{"location":"manifolds/hyperbolic.html#","page":"Hyperbolic space","title":"Hyperbolic space","text":"Modules = [Manifolds]\nPages = [\"manifolds/Hyperbolic.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/hyperbolic.html#Manifolds.Hyperbolic","page":"Hyperbolic space","title":"Manifolds.Hyperbolic","text":"Hyperbolic{N} <: Manifold\n\nThe hyperbolic space mathbb H^n represented by n+1-Tuples, i.e. in by vectors in mathbb R^n+1 using the Minkowsi metric, i.e.\n\nmathbb H^n = Biglxinmathbb R^n+1\n Big langle xx rangle_mathrmM= -x_n+1^2\n+ displaystylesum_k=1^n x_k^2 = -1 x_n+1  0Bigr\n\nwhere langlecdotcdotrangle_mathrmM denotes the minkowski_dot is Minkowski inner product. The tangent space T_xmathbb H^n is given by\n\nT_xmathbb H^n coloneqq bigl\nv in mathbb R^n+1  bigl  langle xvrangle_mathrmM = 0\nbigr\n\nThe Minkowski inner product inntroduces the MinkowskiMetric, which is a Riemannian metric on the tangent bundle Tmathbb H^n.\n\nConstructor\n\nHyperbolic(n)\n\nGenerate the mathbb H^nsubset mathbb R^n+1\n\n\n\n","category":"type"},{"location":"manifolds/hyperbolic.html#Manifolds.MinkowskiMetric","page":"Hyperbolic space","title":"Manifolds.MinkowskiMetric","text":"MinkowskiMetric <: LorentzMetric\n\nThe Minkowski metric is a LorentzMetric with, i.e.\n\nlangle abrangle_mathrmM = -a_n+1b_n+1 +\ndisplaystylesum_k=1^n a_kb_k\n\nIt is also the default metric e.g. for the Hyperbolic space.\n\nnote: Note\nWhile the MinkowskiMetric itself is not positive definite in the whole embedded space, it is positive definite when restricted to a tangent space T_xmathcal M, xinmathcal M, of the Hyperbolic space mathcal M.\n\n\n\n","category":"type"},{"location":"manifolds/hyperbolic.html#Base.exp-Tuple{Hyperbolic,Vararg{Any,N} where N}","page":"Hyperbolic space","title":"Base.exp","text":"exp(M::Hyperbolic, x, v)\n\nCompute the exponential map on the Hyperbolic space mathbb H^n eminating from x towards v, which is optionally scaled by t. The formula reads\n\nexp_x v = cosh(sqrtlangle vvrangle_mathrmM)x\n+ sinh(sqrtlangle vvrangle_mathrmM)fracvsqrtlangle vvrangle_mathrmM\n\nwhere langlecdotcdotrangle_mathrmM denotes the minkowski_dot.\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#Base.log-Tuple{Hyperbolic,Vararg{Any,N} where N}","page":"Hyperbolic space","title":"Base.log","text":"log(M::Hyperbolic, x, y)\n\nCompute the logarithmic map on the Hyperbolic space mathbb H^n, the tangent vector representing the geodesic starting from x reaches y after time 1 on the Hyperbolic space M. The formula reads for xneq y\n\nlog_x y = d_mathbb H^n(xy)\nfracy-langle xyrangle_mathrmM xlVert y-langle xyrangle_mathrmM x rVert_2\n\nand is zero otherwise.\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#ManifoldsBase.distance-Tuple{Hyperbolic,Any,Any}","page":"Hyperbolic space","title":"ManifoldsBase.distance","text":"distance(M::Hyperbolic, x, y)\n\nCompute the distance on the Hyperbolic M, which reads\n\nd_mathbb H^n(xy) = operatornameacosh( - langle x y rangle_mathrmM)\n\nwhere langlecdotcdotrangle_mathrmM denotes the minkowski_dot.\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#ManifoldsBase.injectivity_radius-Tuple{Hyperbolic,Vararg{Any,N} where N}","page":"Hyperbolic space","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::Hyperbolic[, x])\n\nReturn the injectivity radius on the Hyperbolic, which is always infty.\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#ManifoldsBase.inner-Tuple{Hyperbolic,Any,Any,Any}","page":"Hyperbolic space","title":"ManifoldsBase.inner","text":"inner(M::Hyperbolic, x, v, w)\n\nCompute the Riemannian inner product for two tangent vectors v and w from T_xmathbb H^n of the Hyperbolic space mathbb H^n given by langle w v rangle_mathrmM the minkowski_dot Minkowski inner product on mathbb R^n+1.\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#ManifoldsBase.manifold_dimension-Union{Tuple{Hyperbolic{N}}, Tuple{N}} where N","page":"Hyperbolic space","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(H::Hyperbolic)\n\nReturn the dimension of the hyperbolic space manifold mathbb H^n, i.e. n.\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#ManifoldsBase.project_tangent-Tuple{Hyperbolic,Vararg{Any,N} where N}","page":"Hyperbolic space","title":"ManifoldsBase.project_tangent","text":"project_tangent(M::Hyperbolic, x, v)\n\nPerform an orthogonal projection with respect to the Minkowski inner product of v onto the tangent space at x of the Hyperbolic space M.\n\nThe formula reads\n\nw = v + langle xvrangle_mathrmM x\n\nwhere langle cdot cdot rangle_mathrmM denotes the Minkowski inner product in the embedding, see minkowski_dot.\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#ManifoldsBase.representation_size-Union{Tuple{Hyperbolic{N}}, Tuple{N}} where N","page":"Hyperbolic space","title":"ManifoldsBase.representation_size","text":"representation_size(M::Hyperbolic)\n\nReturn the representation size on the Hyperbolic, i.e. for the n-diomensional hyperbolic manifold the dimention of the embedding, i.e. n+1.\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#ManifoldsBase.vector_transport_to-Tuple{Hyperbolic,Any,Any,Any,ParallelTransport}","page":"Hyperbolic space","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::Hyperbolic, x, v, y, ::ParallelTransport)\n\nCompute the paralllel transport of the v from the tangent space at x on the Hyperbolic space mathbb H^n to the tangent at y along the geodesic connecting x and y. The formula reads\n\nP_ygets x(v) = v - fraclangle log_xyvrangle_xd^2_mathbb H^n(xy)\nbigl(log_xy + log_yx bigr)\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#ManifoldsBase.zero_tangent_vector-Tuple{HybridArrays.HybridArray,Vararg{Any,N} where N}","page":"Hyperbolic space","title":"ManifoldsBase.zero_tangent_vector","text":"zero_tangent_vector(M::Hyperbolic, x)\n\nReturn the zero vector from the tangent space at x of the Hyperbolic M.\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#Statistics.mean-Tuple{Hyperbolic,Vararg{Any,N} where N}","page":"Hyperbolic space","title":"Statistics.mean","text":"mean(\n    M::Hyperbolic,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method = CyclicProximalPointEstimationMethod();\n    kwargs...,\n)\n\nCompute the Riemannian mean of x on the Hyperbolic space using CyclicProximalPointEstimation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#Manifolds.minkowski_dot-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}","page":"Hyperbolic space","title":"Manifolds.minkowski_dot","text":"minkowski_dot(a,b)\n\nCompute the Minkowski inner product of two Vectors a and b of same length n+1, i.e.\n\nlangle abrangle_mathrmM = -a_n+1b_n+1 + displaystylesum_k=1^n a_kb_k\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#ManifoldsBase.check_manifold_point-Tuple{Hyperbolic,Any}","page":"Hyperbolic space","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::Hyperbolic, x; kwargs...)\n\nCheck whether x is a valid point on the Hyperbolic M, i.e. is a vector with minkowski_dot -1. The tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/hyperbolic.html#ManifoldsBase.check_tangent_vector-Tuple{Hyperbolic,Any,Any}","page":"Hyperbolic space","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::Hyperbolic, x, v; kwargs... )\n\nCheck whether v is a tangent vector to x on the Hyperbolic M, i.e. after check_manifold_point(M,x), v has to be of same dimension as x and orthogonal to x with respect to minkowski_dot. The tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/power.html#Power-manifold-1","page":"Power manifold","title":"Power manifold","text":"","category":"section"},{"location":"manifolds/power.html#","page":"Power manifold","title":"Power manifold","text":"Modules = [Manifolds]\nPages = [\"manifolds/PowerManifold.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/power.html#Manifolds.AbstractPowerManifold","page":"Power manifold","title":"Manifolds.AbstractPowerManifold","text":"AbstractPowerManifold{M,TPR} <: Manifold\n\nAn abstract Manifold to represent manifolds that are build as powers of another Manifold M with representation type TPR, a subtype of AbstractPowerRepresentation.\n\n\n\n","category":"type"},{"location":"manifolds/power.html#Manifolds.AbstractPowerRepresentation","page":"Power manifold","title":"Manifolds.AbstractPowerRepresentation","text":"AbstractPowerRepresentation\n\nAn abstract representation type of points and tangent vectors on a power manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/power.html#Manifolds.MultidimentionalArrayPowerRepresentation","page":"Power manifold","title":"Manifolds.MultidimentionalArrayPowerRepresentation","text":"MultidimentionalArrayPowerRepresentation\n\nRepresentation of points and tangent vectors on a power manifold using multidimensional arrays where first dimensions are equal to representation_size of the wrapped manifold and the following ones are equal to the number of elements in each direction.\n\nTorus uses this representation.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/power.html#Manifolds.NestedPowerRepresentation","page":"Power manifold","title":"Manifolds.NestedPowerRepresentation","text":"NestedPowerRepresentation\n\nRepresentation of points and tangent vectors on a power manifold using arrays of size equal to TSize of a PowerManifold. Each element of such array stores a single point or tangent vector.\n\nGraphManifold uses this representation.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/power.html#Manifolds.PowerManifold","page":"Power manifold","title":"Manifolds.PowerManifold","text":"PowerManifold{TM<:Manifold, TSize<:Tuple, TPR<:AbstractPowerRepresentation} <: AbstractPowerManifold{TM}\n\nThe power manifold mathcal M^n_1 times n_2 times dots times n_d with power geometry  TSize statically defines the number of elements along each axis.\n\nFor example, a manifold-valued time series would be represented by a power manifold with d equal to 1 and n_1 equal to the number of samples. A manifold-valued image (for example in diffusion tensor imaging) would be represented by a two-axis power manifold (d=2) with n_1 and n_2 equal to width and height of the image.\n\nWhile the size of the manifold is static, points on the power manifold would not be represented by statically-sized arrays. Operations on small power manifolds might be faster if they are represented as ProductManifold.\n\nConstructor\n\nPowerManifold(M, N_1, N_2, ..., N_n)\nPowerManifold(M, NestedPowerRepresentation(), N_1, N_2, ..., N_n)\n\nGenerate the power manifold M^N_1 times N_2 times dots times N_n. By default, the MultidimentionalArrayPowerRepresentation of points and tangent vectors is used, although a different one, for example NestedPowerRepresentation, can be given as the second argument to the constructor.\n\n\n\n","category":"type"},{"location":"manifolds/power.html#Manifolds.PowerMetric","page":"Power manifold","title":"Manifolds.PowerMetric","text":"PowerMetric <: Metric\n\nRepresent the Metric on an AbstractPowerManifold, i.e. the inner product on the tangent space is the sum of the inner product of each elements tangent space of the power manifold.\n\n\n\n","category":"type"},{"location":"manifolds/power.html#Base.exp-Tuple{AbstractPowerManifold,Vararg{Any,N} where N}","page":"Power manifold","title":"Base.exp","text":"exp(M::AbstractPowerManifold, x, v)\n\nCompute the exponential map from x in direction v on the AbstractPowerManifold M, which can be computed using the base manifolds exponential map elementwise.\n\n\n\n","category":"method"},{"location":"manifolds/power.html#Base.log-Tuple{AbstractPowerManifold,Vararg{Any,N} where N}","page":"Power manifold","title":"Base.log","text":"log(M::AbstractPowerManifold, x, y)\n\nCompute the logarithmic map from x to y on the AbstractPowerManifold M, which can be computed using the base manifolds logarithmic map elementwise.\n\n\n\n","category":"method"},{"location":"manifolds/power.html#LinearAlgebra.norm-Tuple{AbstractPowerManifold,Any,Any}","page":"Power manifold","title":"LinearAlgebra.norm","text":"norm(M::AbstractPowerManifold, x, v)\n\nCompute the norm of v from the tangent space of x on an AbstractPowerManifold M, i.e. from the element wise norms the Frobenius norm is computed.\n\n\n\n","category":"method"},{"location":"manifolds/power.html#Manifolds.flat-Tuple{AbstractPowerManifold,Vararg{Any,N} where N}","page":"Power manifold","title":"Manifolds.flat","text":"flat(M::AbstractPowerManifold, x, w::FVector{TangentSpaceType})\n\nuse the musical isomorphism to transform the tangent vector w from the tangent space at x on an AbstractPowerManifold M to a cotangent vector. This can be done elementwise, so r every entry of w (and x) sparately\n\n\n\n","category":"method"},{"location":"manifolds/power.html#Manifolds.sharp-Tuple{AbstractPowerManifold,Vararg{Any,N} where N}","page":"Power manifold","title":"Manifolds.sharp","text":"sharp(M::AbstractPowerManifold, x, w::FVector{CotangentSpaceType})\n\nUse the musical isomorphism to transform the cotangent vector w from the tangent space at x on an AbstractPowerManifold M to a tangent vector. This can be done elementwise, so for every entry of w (and x) sparately\n\n\n\n","category":"method"},{"location":"manifolds/power.html#ManifoldsBase.distance-Tuple{AbstractPowerManifold,Any,Any}","page":"Power manifold","title":"ManifoldsBase.distance","text":"distance(M::AbstractPowerManifold, x, y)\n\nCompute the distance between x and y on an AbstractPowerManifold, i.e. from the element wise distances the Forbenius norm is computed.\n\n\n\n","category":"method"},{"location":"manifolds/power.html#ManifoldsBase.injectivity_radius-Tuple{AbstractPowerManifold,Any}","page":"Power manifold","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::AbstractPowerManifold[, x])\n\nthe injectivity radius on an AbstractPowerManifold is for the global case equal to the one of its base manifold. For a given point x it's equal to the minimum of all radii in the array entries.\n\n\n\n","category":"method"},{"location":"manifolds/power.html#ManifoldsBase.inner-Tuple{AbstractPowerManifold,Any,Any,Any}","page":"Power manifold","title":"ManifoldsBase.inner","text":"inner(M::AbstractPowerManifold, x, v, w)\n\nCompute the inner product of v and w from the tangent space at x on an AbstractPowerManifold M, i.e. for each arrays entry the tangent vector entries from v and w are in the tangent space of the corresponding element from x. The inner product is then the sum of the elementwise inner products.\n\n\n\n","category":"method"},{"location":"manifolds/power.html#ManifoldsBase.inverse_retract-Tuple{AbstractPowerManifold,Vararg{Any,N} where N}","page":"Power manifold","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::AbstractPowerManifold, x, y, m::InversePowerRetraction)\n\nCompute the inverse retraction from x with respect to y on an AbstractPowerManifold M using an InversePowerRetraction, which by default encapsulates a inverse retraction of the base manifold. Then this method is performed elementwise, so the encapsulated inverse retraction method has to be one that is available on the base Manifold.\n\n\n\n","category":"method"},{"location":"manifolds/power.html#ManifoldsBase.manifold_dimension-Union{Tuple{PowerManifold{#s75,TSize,TPR} where TPR<:AbstractPowerRepresentation where #s75<:Manifold}, Tuple{TSize}} where TSize","page":"Power manifold","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::PowerManifold)\n\nReturns the manifold-dimension of an PowerManifold M =mathcal N = (mathcal M)^n_1ldotsn_d ie with n=(n_1ldotsn_d) the array size of the power manifold and d_mathcal M the dimension of the base manifold mathcal M, the manifold is of dimension\n\nd_mathcal N = d_mathcal Mprod_i=1^d n_i = n_1n_2cdotldotscdot n_d d_mathcal M\n\n\n\n","category":"method"},{"location":"manifolds/power.html#ManifoldsBase.retract-Tuple{AbstractPowerManifold,Vararg{Any,N} where N}","page":"Power manifold","title":"ManifoldsBase.retract","text":"retract(M::AbstractPowerManifold, x, v, m::PowerRetraction)\n\nCompute the retraction from x with tangent vector v on an AbstractPowerManifold M using an PowerRetraction, which by default encapsulates a retraction of the base manifold. Then this method is performed elementwise, so the encapsulated retraction method has to be one that is available on the base Manifold.\n\n\n\n","category":"method"},{"location":"manifolds/power.html#Manifolds.InversePowerRetraction","page":"Power manifold","title":"Manifolds.InversePowerRetraction","text":"InversePowerRetraction(inverse_retractions::AbstractInverseRetractionMethod...)\n\nPower inverse retraction of inverse_retractions. Works on AbstractPowerManifolds.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/power.html#Manifolds.PowerFVectorDistribution","page":"Power manifold","title":"Manifolds.PowerFVectorDistribution","text":"PowerFVectorDistribution([type::VectorBundleFibers], [x], distr)\n\nGenerates a random vector at point x from vector space (a fiber of a tangent bundle) of type type using the power distribution of distr.\n\nVector space type and x can be automatically inferred from distribution distr.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/power.html#Manifolds.PowerPointDistribution","page":"Power manifold","title":"Manifolds.PowerPointDistribution","text":"PowerPointDistribution(M::AbstractPowerManifold, distribution)\n\nPower distribution on manifold M, based on distribution.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/power.html#Manifolds.PowerRetraction","page":"Power manifold","title":"Manifolds.PowerRetraction","text":"PowerRetraction(retraction::AbstractRetractionMethod)\n\nPower retraction based on retraction. Works on AbstractPowerManifolds.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/power.html#Manifolds.PrecomputedPowerOrthonormalBasis","page":"Power manifold","title":"Manifolds.PrecomputedPowerOrthonormalBasis","text":"PrecomputedPowerOrthonormalBasis(\n    bases::AbstractArray{AbstractPrecomputedOrthonormalBasis},\n    F::AbstractNumbers = â„,\n)\n\nA precomputed orthonormal basis of a tangent space of a power manifold. The array bases stores bases corresponding to particular parts of the manifold.\n\nThe type parameter F denotes the AbstractNumbers that will be used as scalars.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/power.html#ManifoldsBase.check_manifold_point-Tuple{AbstractPowerManifold,Any}","page":"Power manifold","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::AbstractProductManifold, x; kwargs...)\n\nCheck whether x is a valid point on an AbstractPowerManifold M, i.e. each element of x has to be a valid point on the base manifold.\n\nThe tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/power.html#ManifoldsBase.check_tangent_vector-Tuple{AbstractPowerManifold,Any,Any}","page":"Power manifold","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::AbstractPowerManifold, x, v; kwargs... )\n\nCheck whether v is a tangent vector to x an the AbstractPowerManifold M, i.e. atfer check_manifold_point(M, x), and all projections to base manifolds must be respective tangent vectors.\n\nThe tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.jl-â€“-an-interface-for-manifolds-1","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl â€“ an interface for manifolds","text":"","category":"section"},{"location":"interface.html#","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"The interface for a manifold is provided in the lightweight package `ManifoldsBase.jl separate from the collection of manifolds in here. You can easily implement your algorithms and even your own manifolds just using the interface.","category":"page"},{"location":"interface.html#","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"Pages = [\"interface.md\"]\nDepth = 2","category":"page"},{"location":"interface.html#Types-and-functions-1","page":"ManifoldsBase.jl","title":"Types and functions","text":"","category":"section"},{"location":"interface.html#","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"The following functions are currently available from the interface. If a manifold that you implement for your own package fits this interface, we happily look forward to a Pull Request to add it here.","category":"page"},{"location":"interface.html#","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"Modules = [Manifolds, ManifoldsBase]\nPages = [\"ManifoldsBase.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"interface.html#ManifoldsBase.CoTVector","page":"ManifoldsBase.jl","title":"ManifoldsBase.CoTVector","text":"CoTVector\n\nType for a cotangent vector of a manifold. While a Manifold does not necessarily require this type, for example when it is implemented for Vectors or Matrix type elements, this type can be used for more complicated representations, semantic verification, or even dispatch for different representations of cotangent vectors and their types on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.MPoint","page":"ManifoldsBase.jl","title":"ManifoldsBase.MPoint","text":"MPoint\n\nType for a point on a manifold. While a Manifold does not necessarily require this type, for example when it is implemented for Vectors or Matrix type elements, this type can be used for more complicated representations, semantic verification, or even dispatch for different representations of points on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.Manifold","page":"ManifoldsBase.jl","title":"ManifoldsBase.Manifold","text":"Manifold\n\nA manifold type. The Manifold is used to dispatch to different functions on a manifold, usually as the first argument of the function. Examples are the exponential and logarithmic maps as well as more general functions that are built on them like the geodesic.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.ParallelTransport","page":"ManifoldsBase.jl","title":"ManifoldsBase.ParallelTransport","text":"ParallelTransport <: AbstractVectorTransportMethod\n\nSpecify to use parallel transport as vector transport method within vector_transport_to, vector_transport_direction, or vector_transport_along.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.ProjectionTransport","page":"ManifoldsBase.jl","title":"ManifoldsBase.ProjectionTransport","text":"ProjectionTransport <: AbstractVectorTransportMethod\n\nSpecify to use projection onto tangent space as vector transport method within vector_transport_to, vector_transport_direction, or vector_transport_along. See project_tangent for details.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.TVector","page":"ManifoldsBase.jl","title":"ManifoldsBase.TVector","text":"TVector\n\nType for a tangent vector of a manifold. While a Manifold does not necessarily require this type, for example when it is implemented for Vectors or Matrix type elements, this type can be used for more complicated representations, semantic verification, or even dispatch for different representations of tangent vectors and their types on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#Base.exp-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"Base.exp","text":"exp(M::Manifold, x, v, t::Real = 1)\nexp(M::Manifold, x, v, T::AbstractVector) -> AbstractVector\n\nExponential map of tangent vector t*v at point x from manifold M. t may be a scalar or elements of vector T.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#Base.isapprox-Tuple{Manifold,Any,Any,Any}","page":"ManifoldsBase.jl","title":"Base.isapprox","text":"isapprox(M::Manifold, x, v, w; kwargs...)\n\nCheck if vectors v and w tangent at x from manifold M are approximately equal.\n\nKeyword arguments can be used to specify tolerances.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#Base.isapprox-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"Base.isapprox","text":"isapprox(M::Manifold, x, y; kwargs...)\n\nCheck if points x and y from manifold M are approximately equal.\n\nKeyword arguments can be used to specify tolerances.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#Base.log-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"Base.log","text":"log(M::Manifold, x, y)\n\nLogarithmic map of point y at base point x on Manifold M.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#LinearAlgebra.norm-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"LinearAlgebra.norm","text":"norm(M::Manifold, x, v)\n\nNorm of tangent vector v at point x from manifold M.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.allocate-Tuple{Any,Vararg{Any,N} where N}","page":"ManifoldsBase.jl","title":"ManifoldsBase.allocate","text":"allocate(a)\nallocate(a, dims::Int...)\nallocate(a, dims::Tuple)\nallocate(a, T::Type)\nallocate(a, T::Type, dims::Int...)\nallocate(a, T::Type, dims::Tuple)\n\nAllocate an object similar to a. It is similar to function similar, although instead of working only on the outermost layer of a nested structure, it maps recursively through outer layers and calls similar on the innermost array-like object only. Type T is the new number element type number_eltype, if it is not given the element type of a is retained. The dims argument can be given for non-nested allocation and is forwarded to the function similar.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.base_manifold-Tuple{Manifold}","page":"ManifoldsBase.jl","title":"ManifoldsBase.base_manifold","text":"base_manifold(M::Manifold)\n\nReturn the internally stored manifold for decorated manifolds and the base manifold for vector bundles or power manifolds.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.check_manifold_point-Tuple{Manifold,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::Manifold, x; kwargs...) -> Union{Nothing,String}\n\nReturn nothing when x is a point on manifold M. Otherwise, return a string with a description why the point does not belong to manifold M.\n\nBy default, check_manifold_point returns nothing, i.e. if no checks are implemented, the assumption is to be optimistic for a point not deriving from the MPoint type.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.check_tangent_vector-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::Manifold, x, v; kwargs...) -> Union{Nothing,String}\n\nCheck whether v is a valid tangent vector in the tangent plane of x on the Manifold M. An implementation should first call check_manifold_point(M, x; kwargs...) and then validate v. If it is not a tangent vector, an error string should be returned.\n\nBy default, check_tangent_vector returns nothing, i.e. if no checks are implemented, the assumption is to be optimistic for tangent vectors not deriving from the TVector type.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.distance-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.distance","text":"distance(M::Manifold, x, y)\n\nShortest distance between the points x and y on manifold M.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.exp!-Tuple{Manifold,Any,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.exp!","text":"exp!(M::Manifold, y, x, v, t::Real = 1)\n\nExponential map of tangent vector t*v at point x from manifold M. Result is saved to y.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.geodesic-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.geodesic","text":"geodesic(M::Manifold, x, v) -> Function\n\nGet the geodesic with initial point x and velocity v. The geodesic is the curve of constant velocity that is locally distance-minimizing. This function returns a function of time, which may be a Real or an AbstractVector.\n\ngeodesic(M::Manifold, x, v, t::Real)\ngeodesic(M::Manifold, x, v, T::AbstractVector) -> AbstractVector\n\nReturn the point at time t or points at times t in T along the geodesic.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.injectivity_radius-Tuple{Manifold}","page":"ManifoldsBase.jl","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::Manifold, x)\n\nDistance d such that exp(M, x, v) is injective for all tangent vectors shorter than d (i.e. has a left inverse).\n\ninjectivity_radius(M::Manifold)\n\nInfimum of the injectivity radius of all manifold points.\n\ninjectivity_radius(M::Manifold[, x], method::AbstractRetractionMethod)\n\nDistance d such that retract(M, x, v, method) is injective for all tangent vectors shorter than d (i.e. has a left inverse) for point x if provided or all manifold points otherwise.\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.inner-Tuple{Manifold,Any,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.inner","text":"inner(M::Manifold, x, v, w)\n\nInner product of tangent vectors v and w at point x from manifold M.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.inverse_retract!-Tuple{Manifold,Any,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.inverse_retract!","text":"inverse_retract!(M::Manifold, v, x, y[, method::AbstractInverseRetractionMethod])\n\nInverse retraction (cheaper, approximate version of logarithmic map) of points x and y. Result is saved to v.\n\nInverse retraction method can be specified by the last argument, defaulting to LogarithmicInverseRetraction. See the documentation of respective manifolds for available methods.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.inverse_retract-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::Manifold, x, y)\ninverse_retract(M::Manifold, x, y, method::AbstractInverseRetractionMethod\n\nInverse retraction (cheaper, approximate version of logarithmic map) of points x and y from manifold M.\n\nInverse retraction method can be specified by the last argument, defaulting to LogarithmicInverseRetraction. See the documentation of respective manifolds for available methods.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.is_decorator_manifold-Tuple{Manifold}","page":"ManifoldsBase.jl","title":"ManifoldsBase.is_decorator_manifold","text":"is_decorator_manifold(M::Manifold)\n\nIndicate whether a manifold is a decorator manifold, i.e. whether it encapsulates a Manifold with additional features and stores internally the original manifold instance. An example is the ArrayManifold.\n\nCertain functions are just calling themselves on the internal manifold and hence do not need to be reimplemented for decorators again, for example manifold_dimension and especially base_manifold.\n\nIt is assumed that the undecorated (base) manifold is stored in M.manifold. Alternatively, overload base_manifold.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.is_manifold_point","page":"ManifoldsBase.jl","title":"ManifoldsBase.is_manifold_point","text":"is_manifold_point(M::Manifold, x, throw_error = false; kwargs...)\n\nReturn whether x is a valid point on the Manifold M.\n\nIf throw_error is false, the function returns either true or false. If throw_error is true, the function either returns true or throws an error. By default the function calls check_manifold_point(M, x; kwargs...) and checks whether the returned value is nothing or an error.\n\n\n\n\n\n","category":"function"},{"location":"interface.html#ManifoldsBase.is_tangent_vector","page":"ManifoldsBase.jl","title":"ManifoldsBase.is_tangent_vector","text":"is_tangent_vector(M::Manifold, x, v, throw_error = false; kwargs...)\n\nReturn whether v is a valid tangent vector at point x on the Manifold M. Returns either true or false.\n\nThe default is to return true, i.e. if no checks are implemented, the assumption is to be optimistic.\n\n\n\n\n\n","category":"function"},{"location":"interface.html#ManifoldsBase.log!-Tuple{Manifold,Any,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.log!","text":"log!(M::Manifold, v, x, y)\n\nLogarithmic map of point y at base point x on Manifold M. Result is saved to v.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.manifold_dimension-Tuple{Manifold}","page":"ManifoldsBase.jl","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::Manifold)\n\nThe dimension n of real space mathbb R^n to which the neighborhood of each point of the manifold is homeomorphic.\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.number_eltype-Tuple{Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.number_eltype","text":"number_eltype(x)\n\nNumeric element type of the a nested representation of a point or a vector. To be used in conjuntion with allocate or allocate_result.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.project_point!-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.project_point!","text":"project_point!(M::Manifold, y, x)\n\nProject point x from the ambient space onto the manifold M. The point y is overwritten by the projection. The function works only for selected embedded manifolds and is not required to return the closest point.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.project_point-Tuple{Manifold,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.project_point","text":"project_point(M::Manifold, x)\n\nProject point from the ambient space onto the manifold M. The point x is not modified. The function works only for selected embedded manifolds and is not required to return the closest point.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.project_tangent!-Tuple{Manifold,Any,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.project_tangent!","text":"project_tangent!(M::Manifold, w, x, v)\n\nProject ambient space representation of a vector v to a tangent vector at point x from the manifold M. The result is saved in vector w.\n\nThe function works only for selected embedded manifolds and is not required to return the closest vector.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.project_tangent-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.project_tangent","text":"project_tangent(M::Manifold, x, v)\n\nProject ambient space representation of a vector v to a tangent vector at point x from the manifold M.\n\nThe function works only for selected embedded manifolds and is not required to return the closest vector.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.representation_size-Tuple{Manifold}","page":"ManifoldsBase.jl","title":"ManifoldsBase.representation_size","text":"representation_size(M::Manifold)\n\nThe size of an array representing a point on manifold M.\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.retract!-Tuple{Manifold,Any,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.retract!","text":"retract!(M::Manifold, y, x, v[, t::Real=1])\nretract!(M::Manifold, y, x, v[, t::Real=1], method::AbstractRetractionMethod)\n\nRetraction (cheaper, approximate version of exponential map) of tangent vector t*v at point x from manifold M. Result is saved to y.\n\nRetraction method can be specified by the last argument, defaulting to ExponentialRetraction. See the documentation of respective manifolds for available methods.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.retract-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.retract","text":"retract(M::Manifold, x, v[, t::Real=1])\nretract(M::Manifold, x, v[, t::Real=1], method::AbstractRetractionMethod)\n\nRetraction (cheaper, approximate version of exponential map) of tangent vector t*v at point x from manifold M.\n\nRetraction method can be specified by the last argument, defaulting to ExponentialRetraction. See the documentation of respective manifolds for available methods.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.shortest_geodesic-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.shortest_geodesic","text":"shortest_geodesic(M::Manifold, x, y) -> Function\n\nGet a geodesic gamma_x(t) whose length is the shortest path between the points x and y, where gamma_x(0)=x and gamma_x(1)=y. When there are multiple shortest geodesics, there is no guarantee which will be returned.\n\nThis function returns a function of time, which may be a Real or an AbstractVector.\n\nshortest_geodesic(M::Manifold, x, y, t::Real)\nshortest_geodesic(M::Manifold, x, y, T::AbstractVector) -> AbstractVector\n\nReturn the point at time t or points at times t in T along the shortest geodesic.\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.vector_transport_along!-Tuple{Manifold,Any,Any,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.vector_transport_along!","text":"vector_transport_along!(M::Manifold, vto, x, v, c[, method::AbstractVectorTransportMethod])\n\nTransport a vector v at point x along the curve c such that c(0) is equal to x to point c(1) using the method, which defaults to ParallelTransport. The result is saved to vto.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.vector_transport_along-Tuple{Manifold,Any,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.vector_transport_along","text":"vector_transport_along(M::Manifold, x, v, c[, method::AbstractVectorTransportMethod])\n\nTransport a vector v at point x along the curve c such that c(0) is equal to x to point c(1). The default method used is ParallelTransport.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.vector_transport_direction!-Tuple{Manifold,Any,Any,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.vector_transport_direction!","text":"vector_transport_direction!(M::Manifold, vto, x, v, vdir[, method::AbstractVectorTransportMethod])\n\nTransport a vector v at point x in the direction indicated by the tangent vector vdir at point x. The result is saved to vto. By default, exp and vector_transport_to! are used with the method, which defaults to ParallelTransport.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.vector_transport_direction-Tuple{Manifold,Any,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.vector_transport_direction","text":"vector_transport_direction(M::Manifold, x, v, vdir[, method::AbstractVectorTransportMethod])\n\nTransport a vector v at point x in the direction indicated by the tangent vector vdir at point x using the method, which defaults to ParallelTransport.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.vector_transport_to!-Tuple{Manifold,Any,Any,Any,Any,ProjectionTransport}","page":"ManifoldsBase.jl","title":"ManifoldsBase.vector_transport_to!","text":"vector_transport_to!(M::Manifold, vto, x, v, y, method::ProjectionTransport)\n\nTransport a vector v in the tangent space at x on a Manifold M by interpreting it as an element of the embedding and then projecting it onto the tangent space at y.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.vector_transport_to!-Tuple{Manifold,Any,Any,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.vector_transport_to!","text":"vector_transport_to!(M::Manifold, vto, x, v, y[, method::AbstractVectorTransportMethod])\n\nVector transport of vector v at point x to point y. The result is saved to vto. By default, the method is ParallelTransport.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.vector_transport_to-Tuple{Manifold,Any,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::Manifold, x, v, y[, method::AbstractVectorTransportMethod])\n\nTransport a vector v at point x to point y using the method, which defaults to ParallelTransport.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.zero_tangent_vector!-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.zero_tangent_vector!","text":"zero_tangent_vector!(M::Manifold, v, x)\n\nSave to v a vector such that retracting v to manifold M at x produces x.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.zero_tangent_vector-Tuple{Manifold,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.zero_tangent_vector","text":"zero_tangent_vector(M::Manifold, x)\n\nVector v such that retracting v to manifold M at x produces x.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.AbstractEstimationMethod","page":"ManifoldsBase.jl","title":"ManifoldsBase.AbstractEstimationMethod","text":"AbstractEstimationMethod\n\nAbstract type for defining statistical estimation methods.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.AbstractInverseRetractionMethod","page":"ManifoldsBase.jl","title":"ManifoldsBase.AbstractInverseRetractionMethod","text":"AbstractInverseRetractionMethod\n\nAbstract type for methods for inverting a retraction (see inverse_retract).\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.AbstractRetractionMethod","page":"ManifoldsBase.jl","title":"ManifoldsBase.AbstractRetractionMethod","text":"AbstractRetractionMethod\n\nAbstract type for methods for retracting a tangent vector to a manifold.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.AbstractVectorTransportMethod","page":"ManifoldsBase.jl","title":"ManifoldsBase.AbstractVectorTransportMethod","text":"AbstractVectorTransportMethod\n\nAbstract type for methods for transporting vectors.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.ExponentialRetraction","page":"ManifoldsBase.jl","title":"ManifoldsBase.ExponentialRetraction","text":"ExponentialRetraction\n\nRetraction using the exponential map.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.LogarithmicInverseRetraction","page":"ManifoldsBase.jl","title":"ManifoldsBase.LogarithmicInverseRetraction","text":"LogarithmicInverseRetraction\n\nInverse retraction using the logarithmic map.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.OutOfInjectivityRadiusError","page":"ManifoldsBase.jl","title":"ManifoldsBase.OutOfInjectivityRadiusError","text":"OutOfInjectivityRadiusError\n\nAn error thrown when a function (for example logarithmic map or inverse_retract) is given arguments outside of its injectivity_radius.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#Base.angle-Tuple{Manifold,Any,Any,Any}","page":"ManifoldsBase.jl","title":"Base.angle","text":"angle(M::Manifold, x, v, w)\n\nAngle between tangent vectors v and w at point x from manifold M.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.allocate_result-Tuple{Manifold,Any,Vararg{Any,N} where N}","page":"ManifoldsBase.jl","title":"ManifoldsBase.allocate_result","text":"allocate_result(M::Manifold, f, x...)\n\nAllocate an array for the result of function f on manifold M and arguments x... for implementing the non-modifying operation using the modifying operation.\n\nUsefulness of passing a function is demonstrated by methods that allocate results of musical isomorphisms.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.allocate_result_type-Union{Tuple{N}, Tuple{Manifold,Any,Tuple{Vararg{Any,N}}}} where N","page":"ManifoldsBase.jl","title":"ManifoldsBase.allocate_result_type","text":"allocate_result_type(M::Manifold, f, args::NTuple{N,Any}) where N\n\nReturn type of element of the array that will represent the result of function f for manifold M on given arguments args (passed as a tuple).\n\n\n\n\n\n","category":"method"},{"location":"interface.html#DefaultManifold-1","page":"ManifoldsBase.jl","title":"DefaultManifold","text":"","category":"section"},{"location":"interface.html#","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"DefaultManifold is a simplified version of Euclidean and demonstrates a basic interface implementation.","category":"page"},{"location":"interface.html#","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"ManifoldsBase.DefaultManifold","category":"page"},{"location":"interface.html#ManifoldsBase.DefaultManifold","page":"ManifoldsBase.jl","title":"ManifoldsBase.DefaultManifold","text":"DefaultManifold <: Manifold\n\nThis default manifold illustrates the main features of the interface and provides a skeleton to build one's own manifold. It is a simplified/shortened variant of Euclidean from Manifolds.jl.\n\nThis manifold further illustrates how to type your manifold points and tangent vectors. Note that the interface does not require this, but it might be handy in debugging and educative situations to verify correctness of involved variabes.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#Allocation-1","page":"ManifoldsBase.jl","title":"Allocation","text":"","category":"section"},{"location":"interface.html#","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"Non-mutating functions in Manifolds.jl are typically implemented using mutating variants. Allocation of new points is performed using a custom mechanism that relies on the following functions:","category":"page"},{"location":"interface.html#","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"allocate that allocates a new point or vector similar to the given one. This function behaves like similar for simple representations of points and vectors (for example Array{Float64}). For more complex types, such as nested representations of PowerManifold (see NestedPowerRepresentation), FVector types, checked types like ArrayMPoint and more it operates differently. While similar only concerns itself with the higher level of nested structures, allocate maps itself through all levels of nesting until a simple array of numbers is reached and then calls similar. The difference can be most easily seen in the following example:","category":"page"},{"location":"interface.html#","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"julia> x = similar([[1.0], [2.0]])\n2-element Array{Array{Float64,1},1}:\n #undef\n #undef\n\njulia> y = Manifolds.allocate([[1.0], [2.0]])\n2-element Array{Array{Float64,1},1}:\n [6.90031725726027e-310]\n [6.9003678131654e-310]\n\njulia> x[1]\nERROR: UndefRefError: access to undefined reference\nStacktrace:\n [1] getindex(::Array{Array{Float64,1},1}, ::Int64) at ./array.jl:744\n [2] top-level scope at REPL[12]:1\n\njulia> y[1]\n1-element Array{Float64,1}:\n 6.90031725726027e-310","category":"page"},{"location":"interface.html#","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"allocate_result allocates a result of a particular function (for example [exp], [flat], etc.) on a particular manifold with particular arguments. It takes into account the possibility that different arguments may have different numeric number_eltype types thorough the ManifoldsBase.allocate_result_type function.","category":"page"},{"location":"manifolds/rotations.html#Rotations-1","page":"Rotations","title":"Rotations","text":"","category":"section"},{"location":"manifolds/rotations.html#","page":"Rotations","title":"Rotations","text":"The manifold mathrmSO(n) of orthogonal matrices with determinant +1 in mathbb R^ntimes n, i.e.","category":"page"},{"location":"manifolds/rotations.html#","page":"Rotations","title":"Rotations","text":"mathrmSO(n) = biglR in mathbbR^ntimes n big RR^mathrmT =\nR^mathrmTR = mathrmI_n det(R) = 1 bigr","category":"page"},{"location":"manifolds/rotations.html#","page":"Rotations","title":"Rotations","text":"The Lie group mathrmSO(n) is a subgroup of the orthogonal group mathrmO(n) and also known as the special orthogonal group or the set of rotations group. See also SpecialOrthogonal, which is this manifold equipped with the group operation.","category":"page"},{"location":"manifolds/rotations.html#","page":"Rotations","title":"Rotations","text":"Tangent vectors are represented by elements of the corresponding Lie algebra, which is the tangent space at the identity element. This convention allows for more efficient operations on tangent vectors. Tangent spaces at different points are different vector spaces.","category":"page"},{"location":"manifolds/rotations.html#","page":"Rotations","title":"Rotations","text":"Let L_Rcolon mathrmSO(n) to mathrmSO(n) where R in mathrmSO(n) be the left-multiplication by R, that is L_R(S) = RS. The tangent space at rotation R, T_R mathrmSO(n), is related to the tangent space at the identity rotation mathrmI_n by the differential of L_R at identity, (mathrmdL_R)_mathrmI_n colon T_mathrmI_n mathrmSO(n) to T_R mathrmSO(n). For a tangent vector at the identity rotation v in T_mathrmI_n mathrmSO(n) the matrix representation of the corresponding tangent vector w at a rotation R can be obtained by matrix multiplication: w=Rv in T_R mathrmSO(n). You can compare the functions log!(::Manifolds.Rotations, v, x, y) and exp!(::Manifolds.Rotations, y, x, v) to see how it works in practice.","category":"page"},{"location":"manifolds/rotations.html#","page":"Rotations","title":"Rotations","text":"Modules = [Manifolds]\nPages = [\"manifolds/Rotations.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/rotations.html#Manifolds.Rotations","page":"Rotations","title":"Manifolds.Rotations","text":"Rotations{N} <: Manifold\n\nSpecial orthogonal manifold mathrmSO(n) represented by ntimes n real-valued orthogonal matrices with determinant +1.\n\nConstructor\n\nRotations(n)\n\nGenerate the mathrmSO(n) subset mathbb R^ntimes n\n\n\n\n","category":"type"},{"location":"manifolds/rotations.html#Base.exp-Tuple{Rotations,Vararg{Any,N} where N}","page":"Rotations","title":"Base.exp","text":"exp(M::Rotations, x, v)\n\nCompute the exponential map on the Rotations from x into direction v, i.e.\n\nexp_xv = x operatornameExp(v)\n\nwhere operatornameExp(v)  denotes the matrix exponential of v.\n\nexp(M::Rotations{4}, x, v)\n\nCompute the exponential map of tangent vector v at point x from mathrmSO(4) manifold M.\n\nThe algorithm used is a more numerically stable form of those proposed in [Gallier2002] and [Andrica2013].\n\n[Gallier2002]: \n\nGallier J.; Xu D.; Computing exponentials of skew-symmetric matrices and logarithms of orthogonal matrices. International Journal of Robotics and Automation (2002), 17(4), pp. 1-11. pdf.\n\n[Andrica2013]: \n\nAndrica D.; Rohan R.-A.; Computing the Rodrigues coefficients of the exponential map of the Lie groups of matrices. Balkan Journal of Geometry and Its Applications (2013), 18(2), pp. 1-2. pdf.\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Base.log-Tuple{Rotations,Vararg{Any,N} where N}","page":"Rotations","title":"Base.log","text":"log(M::Rotations, x, y)\n\nCompute the logarithmic map on the Rotations manifold M=mathrmSO(n), which is given by\n\nlog_x y =\n  frac12 bigl(operatornameLog(x^mathrmTy)\n  - (operatornameLog x^mathrmTy)^mathrmT)\n\nwhere operatornameLog denotes the matrix logarithm.\n\nFor antipodal rotations the function returns deterministically one of the tangent vectors that point at y.\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#LinearAlgebra.norm-Tuple{Rotations,Any,Any}","page":"Rotations","title":"LinearAlgebra.norm","text":"norm(M::Rotations, x, v)\n\nCompute the norm of a tangent vector v from the tangent space at x on the Rotations M. The formula reads\n\nlVert v rVert_x = lVert v rVert\n\ni.e. the Frobenius norm of v, where tangent vectors are represented by elements from the Lie group.\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Manifolds.hat-Tuple{Rotations,Vararg{Any,N} where N}","page":"Rotations","title":"Manifolds.hat","text":"hat(M::Rotations, x, Ï‰)\n\nConvert the unique tangent vector components omega at point x on rotations group mathrmSO(n) to the matrix representation Omega of the tangent vector. See vee for the conventions used.\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Manifolds.normal_tvector_distribution-Tuple{Rotations,Any,Any}","page":"Rotations","title":"Manifolds.normal_tvector_distribution","text":"normal_tvector_distribution(M::Rotations, x, Ïƒ)\n\nNormal distribution in ambient space with standard deviation Ïƒ projected to tangent space at x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Manifolds.vee-Tuple{Rotations,Vararg{Any,N} where N}","page":"Rotations","title":"Manifolds.vee","text":"vee(M::Rotations, x, Î©)\n\nExtract the unique tangent vector components omega at point x on rotations group mathrmSO(n) from the matrix representation Omega of the tangent vector.\n\nThe basis on the Lie algebra mathfrakso(n) is chosen such that for mathrmSO(2), omega=theta=Omega_21 is the angle of rotation, and for mathrmSO(3), omega = (Omega_32 Omega_13 Omega_21) = theta u is the angular velocity and axis-angle representation, where u is the unit vector along the axis of rotation.\n\nFor mathrmSO(n) where n ge 4, the additional elements of omega are omega_i (i - 3)2 + j + 1 = Omega_ij, for i in 4 n j in 1i).\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.injectivity_radius-Tuple{Rotations}","page":"Rotations","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::Rotations)\ninjectivity_radius(M::Rotations, x)\n\nReturn the injectivity radius on the Rotations M, which is globally\n\n    operatornameinj_mathrmSO(n)(x) = pisqrt2\n\ninjectivity_radius(M::Rotations, x, ::PolarRetraction)\n\nReturn the radius of injectivity for the PolarRetraction on the Rotations M which is fracpisqrt2.\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.inner-Tuple{Rotations,Any,Any,Any}","page":"Rotations","title":"ManifoldsBase.inner","text":"inner(M::Rotations, x, w, v)\n\nCompute the inner product of the two tangent vectors w, v from the tangent plane at x on the special orthogonal space M=mathrmSO(n) using the restriction of the metric from the embedding, i.e.\n\n(v w)_x = operatornametr(v^T w)\n\n.\n\nTangent vectors are represented by matrices.\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.inverse_retract-Tuple{Rotations,Any,Any,PolarInverseRetraction}","page":"Rotations","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M, x, y, ::PolarInverseRetraction)\n\nCompute a vector from the tangent space T_xmathrmSO(n) of the point x on the Rotations manifold M with which the point y can be reached by the PolarRetraction from the point x after time 1.\n\nThe formula reads\n\noperatornameretr^-1_x(y)\n= -frac12(x^mathrmTys - (x^mathrmTys)^mathrmT)\n\nwhere s is the solution to the Sylvester equation\n\nx^mathrmTys + s(x^mathrmTy)^mathrmT + 2mathrmI_n = 0\n\ninverse_retract(M::Rotations, x, y, ::QRInverseRetraction)\n\nCompute a vector from the tangent space T_xmathrmSO(n) of the point x on the Rotations manifold M with which the point y can be reached by the QRRetraction from the point x after time 1.\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.manifold_dimension-Union{Tuple{Rotations{N}}, Tuple{N}} where N","page":"Rotations","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::Rotations)\n\nReturn the dimension of the manifold mathrmSO(n), i.e. fracn(n-1)2.\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.project_point-Tuple{Rotations,Vararg{Any,N} where N}","page":"Rotations","title":"ManifoldsBase.project_point","text":"project_point(M::Rotations, x; check_det = true)\n\nProject x to the nearest point on manifold M.\n\nGiven the singular value decomposition x = U Sigma V^mathrmT, with the singular values sorted in descending order, the projection is\n\noperatornameproj_mathrmSO(n)(x) =\nUoperatornamediagleft11dotsdet(U V^mathrmT)right V^mathrmT\n\nThe diagonal matrix ensures that the determinant of the result is +1. If x is expected to be almost special orthogonal, then you may avoid this check with check_det = false.\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.project_tangent-Tuple{Rotations,Vararg{Any,N} where N}","page":"Rotations","title":"ManifoldsBase.project_tangent","text":"project_tangent(M::Rotations, x, v)\n\nProject the matrix v onto the tangent space by making v skew symmetric,\n\noperatornameproj_x(v) = fracv-v^mathrmT2\n\nwhere tangent vectors are represented by elements from the Lie group\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.representation_size-Union{Tuple{Rotations{N}}, Tuple{N}} where N","page":"Rotations","title":"ManifoldsBase.representation_size","text":"representation_size(M::Rotations)\n\nReturn the size() of a point on the Rotations M, i.e. for the mathrmSO(n) it's (n,n).\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.retract-Tuple{Rotations,Vararg{Any,N} where N}","page":"Rotations","title":"ManifoldsBase.retract","text":"retract(M, x, v)\nretract(M, x, v, ::QRRetraction)\n\nCompute the SVD-based retraction on the Rotations M from x in direction v (as an element of the Lie group) and is a first-order approximation of the exponential map.\n\nThis is also the default retraction on the Rotations\n\nretract(M::Rotations, x, v, ::PolarRetraction)\n\nCompute the SVD-based retraction on the Rotations M from x in direction v (as an element of the Lie group) and is a second-order approximation of the exponential map. Let\n\nUSV = x + xv\n\nbe the singular value decomposition, then the formula reads\n\noperatornameretr_x v = UV^mathrmT\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.zero_tangent_vector-Tuple{Rotations,Any}","page":"Rotations","title":"ManifoldsBase.zero_tangent_vector","text":"zero_tangent_vector(M::Rotations, x)\n\nReturn the zero tangent vector from the tangent space art x on the Rotations as an element of the Lie group, i.e. the zero matrix.\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Statistics.mean-Tuple{Rotations,Any}","page":"Rotations","title":"Statistics.mean","text":"mean(\n    M::Rotations,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method = GeodesicInterpolationWithinRadius(Ï€/2/âˆš2);\n    kwargs...,\n)\n\nCompute the Riemannian mean of x using GeodesicInterpolationWithinRadius.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Manifolds.NormalRotationDistribution","page":"Rotations","title":"Manifolds.NormalRotationDistribution","text":"NormalRotationDistribution(M::Rotations, d::Distribution, x::TResult)\n\nDistribution that returns a random point on the manifold Rotations M. Random point is generated using base distribution d and the type of the result is adjusted to TResult.\n\nSee normal_rotation_distribution for details.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/rotations.html#Manifolds.angles_4d_skew_sym_matrix-Tuple{Any}","page":"Rotations","title":"Manifolds.angles_4d_skew_sym_matrix","text":"angles_4d_skew_sym_matrix(A)\n\nThe Lie algebra of mathrmSO(4) consists of 4x4 skew-symmetric matrices. The unique imaginary components of their eigenvalues are the angles of the two plane rotations. This function computes these more efficiently than eigvals.\n\nBy convention, the returned values are sorted in decreasing order (corresponding to the same ordering of angles as cos_angles_4d_rotation_matrix).\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Manifolds.cos_angles_4d_rotation_matrix-Tuple{Any}","page":"Rotations","title":"Manifolds.cos_angles_4d_rotation_matrix","text":"cos_angles_4d_rotation_matrix(R)\n\n4D rotations can be described by two orthogonal planes that are unchanged by the action of the rotation (vectors within a plane rotate only within the plane). The cosines of the two angles of rotation about these planes may be obtained from the distinct real parts of the eigenvalues of the rotation matrix. This function computes these more efficiently by solving the system\n\nbeginaligned\ncosalpha + cosbeta = frac12 operatornametr(R)\ncosalpha + cosbeta = frac18 operatornametr(R)^2\n                           - frac116 operatornametr((R - R^T)^2) - 1\nendaligned\n\nBy convention, the returned values are sorted in increasing order. See angles_4d_skew_sym_matrix. For derivation of the above, see [Gallier, 2013].\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Manifolds.normal_rotation_distribution-Union{Tuple{N}, Tuple{Rotations{N},Any,Real}} where N","page":"Rotations","title":"Manifolds.normal_rotation_distribution","text":"normal_rotation_distribution(M::Rotations, x, Ïƒ::Real)\n\nReturn a random point on the manifold Rotations M by generating a (Gaussian) random orthogonal matrix with determinant +1. Let\n\nQR = A\n\nbe the QR decomposition of a random matrix A, then the formula reads\n\nx = QD\n\nwhere D is a diagonal matrix with the signs of the diagonal entries of R, i.e.\n\nD_ij=begincases operatornamesgn(R_ij)  textif  i=j  0   textotherwise endcases\n\nIt can happen that the matrix gets -1 as a determinant. In this case, the first and second columns are swapped.\n\nThe argument x is used to determine the type of returned points.\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.check_manifold_point-Union{Tuple{N}, Tuple{Rotations{N},Any}} where N","page":"Rotations","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M,x; kwargs...)\n\nCheck whether x is a valid point on the Rotations M, i.e. is an array of size manifold_dimension(M) and represents a valid rotation. The tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.check_tangent_vector-Union{Tuple{N}, Tuple{Rotations{N},Any,Any}} where N","page":"Rotations","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M,x,v; kwargs... )\n\nCheck whether v is a tangent vector to x on the Rotations space M, i.e. after check_manifold_point(M,x), v has to be of same dimension as x and orthogonal to x. The tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Literature-1","page":"Rotations","title":"Literature","text":"","category":"section"},{"location":"manifolds/vector_bundle.html#Vector-bundles-1","page":"Vector bundle","title":"Vector bundles","text":"","category":"section"},{"location":"manifolds/vector_bundle.html#","page":"Vector bundle","title":"Vector bundle","text":"Vector bundle E is a manifold that is built on top of another manifold M (base space). It is characterized by a continuous function Pi colon E to M, such that for each point x in M the preimage of x by Pi, Pi^-1(x), has a structure of a vector space. These vector spaces are called fibers. Bundle projection can be performed using function bundle_projection.","category":"page"},{"location":"manifolds/vector_bundle.html#","page":"Vector bundle","title":"Vector bundle","text":"Tangent bundle is a simple example of a vector bundle, where each fiber is the tangent space at the specified point x. An object representing a tangent bundle can be obtained using the constructor called TangentBundle.","category":"page"},{"location":"manifolds/vector_bundle.html#","page":"Vector bundle","title":"Vector bundle","text":"Fibers of a vector bundle are represented by the type VectorBundleFibers. The important difference between functions operating on VectorBundle and VectorBundleFibers is that in the first case both a point on the underlying manifold and the vector are represented together (by a single argument) while in the second case only the vector part is present, while the point is supplied in a different argument where needed.","category":"page"},{"location":"manifolds/vector_bundle.html#","page":"Vector bundle","title":"Vector bundle","text":"VectorBundleFibers refers to the whole set of fibers of a vector bundle. There is also another type, VectorSpaceAtPoint, that represents a specific fiber at a given point. This distinction is made to reduce the need to repeatedly construct objects of type VectorSpaceAtPoint in certain usage scenarios.","category":"page"},{"location":"manifolds/vector_bundle.html#FVector-1","page":"Vector bundle","title":"FVector","text":"","category":"section"},{"location":"manifolds/vector_bundle.html#","page":"Vector bundle","title":"Vector bundle","text":"For cases where confusion between different types of vectors is possible, the type FVector can be used to express which type of vector space the vector belongs to. It is used for example in musical isomorphisms (the flat and sharp functions) that are used to go from a tangent space to cotangent space and vice versa.","category":"page"},{"location":"manifolds/vector_bundle.html#","page":"Vector bundle","title":"Vector bundle","text":"Modules = [Manifolds, ManifoldsBase]\nPages = [\"manifolds/VectorBundle.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/vector_bundle.html#Manifolds.FVector","page":"Vector bundle","title":"Manifolds.FVector","text":"FVector(type::VectorSpaceType, data)\n\nDecorator indicating that the vector data is from a fiber of a vector bundle of type type.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/vector_bundle.html#Manifolds.VectorBundle","page":"Vector bundle","title":"Manifolds.VectorBundle","text":"VectorBundle(M::Manifold, type::VectorSpaceType)\n\nVector bundle on manifold M of type type.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/vector_bundle.html#Manifolds.VectorBundleFibers","page":"Vector bundle","title":"Manifolds.VectorBundleFibers","text":"VectorBundleFibers(VS::VectorSpaceType, M::Manifold)\n\nType representing a family of vector spaces (fibers) of a vector bundle over M with vector spaces of type VS. In contrast with VectorBundle, operations on VectorBundleFibers expect point-like and vector-like parts to be passed separately instead of being bundled together. It can be thought of as a representation of vector spaces from a vector bundle but without storing the point at which a vector space is attached (which is specified separately in various functions).\n\n\n\n\n\n","category":"type"},{"location":"manifolds/vector_bundle.html#Manifolds.VectorSpaceAtPoint","page":"Vector bundle","title":"Manifolds.VectorSpaceAtPoint","text":"VectorSpaceAtPoint(fiber::VectorBundleFibers, x)\n\nA vector space (fiber type fiber of a vector bundle) at point x from the manifold fiber.M.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/vector_bundle.html#Manifolds.VectorSpaceType","page":"Vector bundle","title":"Manifolds.VectorSpaceType","text":"VectorSpaceType\n\nAbstract type for tangent spaces, cotangent spaces, their tensor products, exterior products, etc.\n\nEvery vector space VS is supposed to provide:\n\na method of constructing vectors,\nbasic operations: addition, subtraction, multiplication by a scalar and negation (unary minus),\nzero_vector!(VS, v, x) to construct zero vectors at point x,\nallocate(v) and allocate(v, T) for vector v and type T,\ncopyto!(v, w) for vectors v and w,\nnumber_eltype(v) for vector v,\nvector_space_dimension(::VectorBundleFibers{<:typeof(VS)}) where VS.\n\nOptionally:\n\ninner product via inner (used to provide Riemannian metric on vector bundles),\nflat and sharp,\nnorm (by default uses inner),\nproject_vector (for embedded vector spaces),\nrepresentation_size (if support for ProductArray is desired),\nbroadcasting for basic operations.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/vector_bundle.html#Base.exp-Tuple{VectorBundle,Any}","page":"Vector bundle","title":"Base.exp","text":"exp(B::VectorBundle, x, v)\n\nExponential map of tangent vector v at point x from vector bundle B over manifold B.VS (denoted M).\n\nNotation:\n\nThe point x = (p_x xi_x) where p_x in M and xi_x belongs to the fiber F=pi^-1(p_x) of the vector bundle B where pi is the canonical projection of that vector bundle B.\nThe tangent vector v = (xi_vM xi_vF) in T_xB where xi_vM is a tangent vector from the tangent space T_p_xM and xi_vF is a tangent vector from the tangent space T_xi_xF (isomorphic to F).\n\nThe exponential map is calculated as\n\nexp_x(v) = (exp_p_x(xi_vM) xi_exp)\n\nwhere xi_exp is the result of vector transport of xi_x + xi_vF to the point exp_p_x(xi_vM). The sum xi_x + xi_vF corresponds to the exponential map in the vector space F.\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Base.log-Tuple{VectorBundle,Vararg{Any,N} where N}","page":"Vector bundle","title":"Base.log","text":"log(B::VectorBundle, x, y)\n\nLogarithmic map of the point y at point x from vector bundle B over manifold B.VS (denoted M).\n\nNotation:\n\nThe point x = (p_x xi_x) where p_x in M and xi_x belongs to the fiber F=pi^-1(p_x) of the vector bundle B where pi is the canonical projection of that vector bundle B. Similarly, y = (p_y xi_y).\n\nThe logarithmic map is calculated as\n\nlog_x(y) = (log_p_x(p_y) xi_log - xi_x)\n\nwhere xi_log is the result of vector transport of xi_y to the point p_x. The difference xi_log - xi_x corresponds to the logarithmic map in the vector space F.\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#LinearAlgebra.norm-Tuple{VectorBundleFibers,Any,Any}","page":"Vector bundle","title":"LinearAlgebra.norm","text":"norm(B::VectorBundleFibers, x, v)\n\nNorm of the vector v from the vector space of type B.VS at point x from manifold B.M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.CotangentSpaceAtPoint-Tuple{Manifold,Any}","page":"Vector bundle","title":"Manifolds.CotangentSpaceAtPoint","text":"CotangentSpaceAtPoint(M::Manifold, x)\n\nReturn an object of type VectorSpaceAtPoint representing cotangent space at x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.TangentSpaceAtPoint-Tuple{Manifold,Any}","page":"Vector bundle","title":"Manifolds.TangentSpaceAtPoint","text":"TangentSpaceAtPoint(M::Manifold, x)\n\nReturn an object of type VectorSpaceAtPoint representing tangent space at x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.bundle_projection-Tuple{VectorBundle,Any}","page":"Vector bundle","title":"Manifolds.bundle_projection","text":"bundle_projection(B::VectorBundle, x::ProductRepr)\n\nProjection of point x from the bundle M to the base manifold. Returns the point on the base manifold B.M at which the vector part of x is attached.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.flat-Tuple{Manifold,Any,FVector}","page":"Vector bundle","title":"Manifolds.flat","text":"flat(M::Manifold, x, w::FVector)\n\nCompute the flat isomorphism (one of the musical isomorphisms) of tangent vector w from the vector space of type M at point x from the underlying Manifold.\n\nThe function can be used for example to transform vectors from the tangent bundle to vectors from the cotangent bundle flat colon Tmathcal M to T^*mathcal M\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.sharp-Tuple{Manifold,Any,FVector}","page":"Vector bundle","title":"Manifolds.sharp","text":"sharp(M::Manifold, x, w::FVector)\n\nCompute the sharp isomorphism (one of the musical isomorphisms) of vector w from the vector space M at point x from the underlying Manifold.\n\nThe function can be used for example to transform vectors from the cotangent bundle to vectors from the tangent bundle sharp colon T^*mathcal M to Tmathcal M\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.vector_space_dimension-Tuple{VectorBundleFibers}","page":"Vector bundle","title":"Manifolds.vector_space_dimension","text":"vector_space_dimension(B::VectorBundleFibers)\n\nDimension of the vector space of type B.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.zero_vector!-Tuple{VectorBundleFibers,Any,Any}","page":"Vector bundle","title":"Manifolds.zero_vector!","text":"zero_vector!(B::VectorBundleFibers, v, x)\n\nSave the zero vector from the vector space of type B.VS at point x from manifold B.M to v.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.zero_vector-Tuple{VectorBundleFibers,Any}","page":"Vector bundle","title":"Manifolds.zero_vector","text":"zero_vector(B::VectorBundleFibers, x)\n\nCompute the zero vector from the vector space of type B.VS at point x from manifold B.M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.allocate_result-Tuple{VectorBundleFibers,Any,Vararg{Any,N} where N}","page":"Vector bundle","title":"ManifoldsBase.allocate_result","text":"allocate_result(B::VectorBundleFibers, f, x...)\n\nAllocates an array for the result of function f that is an element of the vector space of type B.VS on manifold B.M and arguments x... for implementing the non-modifying operation using the modifying operation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.distance-Tuple{VectorBundle,Any,Any}","page":"Vector bundle","title":"ManifoldsBase.distance","text":"distance(B::VectorBundle, x, y)\n\nDistance between points x and y from the vector bundle B over manifold B.VS (denoted M).\n\nNotation:\n\nThe point x = (p_x xi_x) where p_x in M and xi_x belongs to the fiber F=pi^-1(p_x) of the vector bundle B where pi is the canonical projection of that vector bundle B. Similarly, y = (p_y xi_y).\n\nThe distance is calculated as\n\nd_B(x y) = sqrtd_M(p_x p_y)^2 + d_F(xi_x xi_yto x)^2\n\nwhere d_M is the distance on manifold M, d_F is the distance between two vectors from the fiber F and xi_yto x is the result of parallel transport of vector xi_y to point p_x. The default behavior of vector_transport_to is used to compute the vector transport.\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.distance-Tuple{VectorBundleFibers,Any,Any,Any}","page":"Vector bundle","title":"ManifoldsBase.distance","text":"distance(B::VectorBundleFibers, x, v, w)\n\nDistance between vectors v and w from the vector space at point x from the manifold M.M, that is the base manifold of M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.inner-Tuple{VectorBundle,Any,Any,Any}","page":"Vector bundle","title":"ManifoldsBase.inner","text":"inner(B::VectorBundle, x, v, w)\n\nInner product of tangent vectors v and w at point x from the vector bundle B over manifold B.VS (denoted M).\n\nNotation:\n\nThe point x = (p_x xi_x) where p_x in M and xi_x belongs to the fiber F=pi^-1(p_x) of the vector bundle B where pi is the canonical projection of that vector bundle B.\nThe tangent vector v = (xi_vM xi_vF) in T_xB where xi_vM is a tangent vector from the tangent space T_p_xM and xi_vF is a tangent vector from the tangent space T_xi_xF (isomorphic to F). Similarly for the other tangent vector w = (xi_wM xi_wF) in T_xB.\n\nThe inner product is calculated as\n\nlangle v w rangle_B = langle xi_vM xi_wM rangle_M + langle xi_vF xi_wF rangle_F\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.inner-Tuple{VectorBundleFibers,Any,Any,Any}","page":"Vector bundle","title":"ManifoldsBase.inner","text":"inner(B::VectorBundleFibers, x, v, w)\n\nInner product of vectors v and w from the vector space of type B.VS at point x from manifold B.M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.project_point-Tuple{VectorBundle,Vararg{Any,N} where N}","page":"Vector bundle","title":"ManifoldsBase.project_point","text":"project_point(B::VectorBundle, x)\n\nProject the point x from the ambient space of the vector bundle B over manifold B.VS (denoted M) to the vector bundle.\n\nNotation:\n\nThe point x = (p_x xi_x) where p_x belongs to the ambient space of M and xi_x belongs to the ambient space of the fiber F=pi^-1(p_x) of the vector bundle B where pi is the canonical projection of that vector bundle B.\n\nThe projection is calculated by projecting the point p_x to the manifold M and then projecting the vector xi_x to the tangent space T_p_xM.\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.project_tangent-Tuple{VectorBundle,Vararg{Any,N} where N}","page":"Vector bundle","title":"ManifoldsBase.project_tangent","text":"project_tangent(B::VectorBundle, x, v)\n\nProject the element v of the ambient space of the tangent space T_x B to the tangent space T_x B.\n\nNotation:\n\nThe point x = (p_x xi_x) where p_x in M and xi_x belongs to the fiber F=pi^-1(p_x) of the vector bundle B where pi is the canonical projection of that vector bundle B.\nThe vector x = (xi_vM xi_vF) where p_x belongs to the ambient space of T_p_xM and xi_vF belongs to the ambient space of the fiber F=pi^-1(p_x) of the vector bundle B where pi is the canonical projection of that vector bundle B.\n\nThe projection is calculated by projecting xi_vM to tangent space T_p_xM and then projecting the vector xi_vF to the fiber F.\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.zero_tangent_vector-Tuple{VectorBundle,Vararg{Any,N} where N}","page":"Vector bundle","title":"ManifoldsBase.zero_tangent_vector","text":"zero_tangent_vector(B::VectorBundle, x)\n\nZero tangent vector at point x from the vector bundle B over manifold B.VS (denoted M). The zero vector belongs to the space T_xB\n\nNotation:\n\nThe point x = (p_x xi_x) where p_x in M and xi_x belongs to the fiber F=pi^-1(p_x) of the vector bundle B where pi is the canonical projection of that vector bundle B.\n\nThe zero vector is calculated as\n\nmathbf0_x = (mathbf0_p_x mathbf0_F)\n\nwhere mathbf0_p_x is the zero tangent vector from T_p_xM and mathbf0_F is the zero element of the vector space F.\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.TensorProductType","page":"Vector bundle","title":"Manifolds.TensorProductType","text":"TensorProductType(spaces::VectorSpaceType...)\n\nVector space type corresponding to the tensor product of given vector space types.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/vector_bundle.html#Manifolds.project_vector-Tuple{VectorBundleFibers,Any,Any}","page":"Vector bundle","title":"Manifolds.project_vector","text":"project_vector(B::VectorBundleFibers, x, w)\n\nProject vector w from the vector space of type B.VS at point x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.allocate_result_type-Union{Tuple{N}, Tuple{VectorBundleFibers,Any,Tuple{Vararg{Any,N}}}} where N","page":"Vector bundle","title":"ManifoldsBase.allocate_result_type","text":"allocate_result_type(B::VectorBundleFibers, f, args::NTuple{N,Any}) where N\n\nReturns type of element of the array that will represent the result of function f for representing an operation with result in the vector space VS for manifold M on given arguments (passed at a tuple).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/torus.html#Torus-1","page":"Torus","title":"Torus","text":"","category":"section"},{"location":"manifolds/torus.html#","page":"Torus","title":"Torus","text":"The torus mathbb T^d equiv -Ï€Ï€)^d is modeled as an AbstractPowerManifold of the (real-valued) Circle and uses MultidimentionalArrayPowerRepresentation. Points on the torus are hence row vectors, xinmathbb R^d.","category":"page"},{"location":"manifolds/torus.html#Example-1","page":"Torus","title":"Example","text":"","category":"section"},{"location":"manifolds/torus.html#","page":"Torus","title":"Torus","text":"The following code can be used to make a three-dimensional torus mathbbT^3 and compute a tangent vector.","category":"page"},{"location":"manifolds/torus.html#","page":"Torus","title":"Torus","text":"using Manifolds\nM = Torus(3)\nx = [0.5, 0.0, 0.0]\ny = [0.0, 0.5, 1.0]\nv = log(M, x, y)","category":"page"},{"location":"manifolds/torus.html#Types-and-functions-1","page":"Torus","title":"Types and functions","text":"","category":"section"},{"location":"manifolds/torus.html#","page":"Torus","title":"Torus","text":"Most functions are directly implemented for an AbstractPowerManifold with MultidimentionalArrayPowerRepresentation except the following special cases.","category":"page"},{"location":"manifolds/torus.html#","page":"Torus","title":"Torus","text":"Modules = [Manifolds]\nPages = [\"manifolds/Torus.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/torus.html#Manifolds.Torus","page":"Torus","title":"Manifolds.Torus","text":"Torus{N} <: AbstractPowerManifold\n\nThe n-dimensionsl torus is the n-dimensional product of the Â´Circle`.\n\nThe Circle is stored internally within manifold, such that all functions of AbstractPowerManifold can be used directly.\n\n\n\n","category":"type"},{"location":"manifolds/torus.html#ManifoldsBase.check_manifold_point-Tuple{Torus,Any}","page":"Torus","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::Torus{n},x)\n\ncheck whether x is a valid point on the GraphManifold\n\n\n\n","category":"method"},{"location":"lib/numbers.html#Number-systems-1","page":"Number systems","title":"Number systems","text":"","category":"section"},{"location":"lib/numbers.html#","page":"Number systems","title":"Number systems","text":"Manifolds.AbstractNumbers\nManifolds.RealNumbers\nManifolds.ComplexNumbers\nManifolds.QuaternionNumbers\nreal_dimension","category":"page"},{"location":"lib/numbers.html#Manifolds.AbstractNumbers","page":"Number systems","title":"Manifolds.AbstractNumbers","text":"AbstractNumbers\n\nAn abstract type to represent the number system on which a manifold is built.\n\nThis provides concrete number types for dispatch. The two most common number types are the fields RealNumbers (â„ for short) and ComplexNumbers (â„‚).\n\n\n\n\n\n","category":"type"},{"location":"lib/numbers.html#Manifolds.RealNumbers","page":"Number systems","title":"Manifolds.RealNumbers","text":"â„ = RealNumbers()\n\nThe field of real numbers.\n\n\n\n\n\n","category":"type"},{"location":"lib/numbers.html#Manifolds.ComplexNumbers","page":"Number systems","title":"Manifolds.ComplexNumbers","text":"â„‚ = ComplexNumbers()\n\nThe field of complex numbers.\n\n\n\n\n\n","category":"type"},{"location":"lib/numbers.html#Manifolds.QuaternionNumbers","page":"Number systems","title":"Manifolds.QuaternionNumbers","text":"â„ = QuaternionNumbers()\n\nThe division algebra of quaternions.\n\n\n\n\n\n","category":"type"},{"location":"lib/numbers.html#Manifolds.real_dimension","page":"Number systems","title":"Manifolds.real_dimension","text":"real_dimension(ð”½::AbstractNumbers)\n\nReturn the real dimension dim_â„ ð”½ of the [AbstractNumbers] system ð”½. The real dimension is the dimension of a real vector space with which a number in ð”½ can be identified. For example, ComplexNumbers have a real dimension of 2, and QuaternionNumbers have a real dimension of 4.\n\n\n\n","category":"function"},{"location":"manifolds/graph.html#Graph-manifold-1","page":"Graph manifold","title":"Graph manifold","text":"","category":"section"},{"location":"manifolds/graph.html#","page":"Graph manifold","title":"Graph manifold","text":"For a given graph G(VE) implemented using LightGraphs.jl, the GraphManifold models a PowerManifold either on the nodes or edges of the graph, depending on the GraphManifoldType. i.e., it's either a mathcal M^lvert V rvert for the case of a vertex manifold or a mathcal M^lvert E rvert for the case of a edge manifold.","category":"page"},{"location":"manifolds/graph.html#Example:-1","page":"Graph manifold","title":"Example:","text":"","category":"section"},{"location":"manifolds/graph.html#","page":"Graph manifold","title":"Graph manifold","text":"To make a graph manifold over mathbbR^2 with three vertices and two edges, one can use","category":"page"},{"location":"manifolds/graph.html#","page":"Graph manifold","title":"Graph manifold","text":"using Manifolds\nusing LightGraphs\nM = Euclidean(2)\nx = [[1., 4.], [2., 5.], [3., 6.]]\ny = [[4., 5.], [6., 7.], [8., 9.]]\nz = [[6., 5.], [4., 3.], [2., 8.]]\nG = SimpleGraph(3)\nadd_edge!(G, 1, 2)\nadd_edge!(G, 2, 3)\nN = GraphManifold(G, M, VertexManifold())","category":"page"},{"location":"manifolds/graph.html#","page":"Graph manifold","title":"Graph manifold","text":"It supports all AbstractPowerManifold operations (it is based on NestedPowerRepresentation) and furthermore it is possible to compute a graph logarithm:","category":"page"},{"location":"manifolds/graph.html#","page":"Graph manifold","title":"Graph manifold","text":"using Manifolds\nusing LightGraphs\nM = Euclidean(2)\nx = [[1., 4.], [2., 5.], [3., 6.]]\ny = [[4., 5.], [6., 7.], [8., 9.]]\nz = [[6., 5.], [4., 3.], [2., 8.]]\nG = SimpleGraph(3)\nadd_edge!(G, 1, 2)\nadd_edge!(G, 2, 3)\nN = GraphManifold(G, M, VertexManifold())","category":"page"},{"location":"manifolds/graph.html#","page":"Graph manifold","title":"Graph manifold","text":"incident_log(N, x)","category":"page"},{"location":"manifolds/graph.html#Types-and-functions-1","page":"Graph manifold","title":"Types and functions","text":"","category":"section"},{"location":"manifolds/graph.html#","page":"Graph manifold","title":"Graph manifold","text":"Modules = [Manifolds]\nPages = [\"manifolds/GraphManifold.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/graph.html#Manifolds.EdgeManifold","page":"Graph manifold","title":"Manifolds.EdgeManifold","text":"EdgeManifoldManifold <: GraphManifoldType\n\nA type for a GraphManifold where the data is given on the edges.\n\n\n\n","category":"type"},{"location":"manifolds/graph.html#Manifolds.GraphManifold","page":"Graph manifold","title":"Manifolds.GraphManifold","text":"GraphManifold{G, M, T} <: AbstractPowerManifold{M,NestedPowerRepresentation}\n\nBuild a manifold, that is a PowerManifold of the Manifold M either on the edges or vertices of a graph G depending on the GraphManifoldType T.\n\nFields\n\nG is an AbstractSimpleGraph\nM is a Manifold\n\n\n\n","category":"type"},{"location":"manifolds/graph.html#Manifolds.GraphManifoldType","page":"Graph manifold","title":"Manifolds.GraphManifoldType","text":"GraphManifoldType\n\nThis type represents the type of data on the graph that the GraphManifold represents.\n\n\n\n","category":"type"},{"location":"manifolds/graph.html#Manifolds.VertexManifold","page":"Graph manifold","title":"Manifolds.VertexManifold","text":"VectexGraphManifold <: GraphManifoldType\n\nA type for a GraphManifold where the data is given on the vertices.\n\n\n\n","category":"type"},{"location":"manifolds/graph.html#Manifolds.incident_log-Tuple{GraphManifold{#s86,#s75,VertexManifold} where #s75<:Manifold where #s86<:LightGraphs.AbstractGraph,Any}","page":"Graph manifold","title":"Manifolds.incident_log","text":"incident_log(M::GraphManifold, x)\n\nReturn the tangent vector on the (vertex) GraphManifold, where at each node the sum of the logs to incident nodes is computed. For a SimpleGraph, an egde is interpreted as double edge in the corresponding SimpleDiGraph\n\nIf the internal graph is a SimpleWeightedGraph the weighted sum of the tangent vectors is computed.\n\n\n\n","category":"method"},{"location":"manifolds/graph.html#ManifoldsBase.manifold_dimension-Tuple{GraphManifold{#s86,#s75,EdgeManifold} where #s75<:Manifold where #s86<:LightGraphs.AbstractGraph}","page":"Graph manifold","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(N::GraphManifold{G,M,EdgeManifold})\n\nreturns the manifold dimension of the GraphManifold N on the edges of a graph G=(VE), i.e.\n\nd_mathcal N = lvert E rVert d_mathcal M\n\n\n\n","category":"method"},{"location":"manifolds/graph.html#ManifoldsBase.manifold_dimension-Tuple{GraphManifold{#s86,#s75,VertexManifold} where #s75<:Manifold where #s86<:LightGraphs.AbstractGraph}","page":"Graph manifold","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(N::GraphManifold{G,M,VertexManifold})\n\nreturns the manifold dimension of the GraphManifold N on the vertices of a graph G=(VE), i.e.\n\nd_mathcal N = lvert V rVert d_mathcal M\n\n\n\n","category":"method"},{"location":"manifolds/graph.html#ManifoldsBase.check_manifold_point-Tuple{GraphManifold,Vararg{Any,N} where N}","page":"Graph manifold","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::GraphManifold, x)\n\nCheck whether x is a valid point on the GraphManifold, i.e. its length equals the number of vertices (for VertexManifolds) or the number of edges (for EdgeManifolds) and that each element of x passes the check_manifold_point test for the base manifold M.manifold.\n\n\n\n","category":"method"},{"location":"manifolds/graph.html#ManifoldsBase.check_tangent_vector-Tuple{GraphManifold,Vararg{Any,N} where N}","page":"Graph manifold","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::GraphManifold, x, v)\n\nCheck whether x is a valid point on the GraphManifold, and v it from its tangent space, i.e. its length equals the number of vertices (for VertexManifolds) or the number of edges (for EdgeManifolds) and that each element of v together with its corresponding einty of x passes the check_tangent_vector test for the base manifold M.manifold.\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Product-manifold-1","page":"Product manifold","title":"Product manifold","text":"","category":"section"},{"location":"manifolds/product.html#","page":"Product manifold","title":"Product manifold","text":"Product manifold M = M_1 times M_2 times dots M_n of manifolds M_1 M_2 dots M_n. Points on the product manifold can be constructed using ProductRepr with canonical projections Pi_i colon M to M_i for i in 1 2 dots n provided by submanifold_component.","category":"page"},{"location":"manifolds/product.html#","page":"Product manifold","title":"Product manifold","text":"Modules = [Manifolds]\nPages = [\"manifolds/ProductManifold.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/product.html#Manifolds.PrecomputedProductOrthonormalBasis","page":"Product manifold","title":"Manifolds.PrecomputedProductOrthonormalBasis","text":"PrecomputedProductOrthonormalBasis(parts::NTuple{N,AbstractPrecomputedOrthonormalBasis} where N, F::AbstractNumbers = â„)\n\nA precomputed orthonormal basis of a tangent space of a product manifold. The tuple parts stores bases corresponding to multiplied manifolds.\n\nThe type parameter F denotes the AbstractNumbers that will be used as scalars.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/product.html#Manifolds.ProductManifold","page":"Product manifold","title":"Manifolds.ProductManifold","text":"ProductManifold{TM<:Tuple, TRanges<:Tuple, TSizes<:Tuple} <: Manifold\n\nProduct manifold M_1 times M_2 times dots times M_n with product geometry. TRanges and TSizes statically define the relationship between representation of the product manifold and representations of point, tangent vectors and cotangent vectors of respective manifolds.\n\nConstructor\n\nProductManifold(M_1, M_2, ..., M_n)\n\ngenerates the product manifold M_1 times M_2 times dots times M_n. Alternatively, the same manifold can be contructed using the Ã— operator: M_1 Ã— M_2 Ã— M_3.\n\n\n\n","category":"type"},{"location":"manifolds/product.html#Base.exp-Tuple{ProductManifold,Vararg{Any,N} where N}","page":"Product manifold","title":"Base.exp","text":"exp(M::ProductManifold, x, v)\n\ncompute the exponential map from x towards v on the ProductManifold M, which is the elementwise exponential map on the internal manifolds that build M.\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Base.log-Tuple{ProductManifold,Vararg{Any,N} where N}","page":"Product manifold","title":"Base.log","text":"log(M::ProductManifold, x, y)\n\nCompute the logarithmic map from x to y on the ProductManifold M, which can be computed using the logarithmic maps of the manifolds elementwise.\n\n\n\n","category":"method"},{"location":"manifolds/product.html#LinearAlgebra.norm-Tuple{ProductManifold,Any,Any}","page":"Product manifold","title":"LinearAlgebra.norm","text":"norm(M::PowerManifold, x, v)\n\nCompute the norm of v from the tangent space of x on the ProductManifold, i.e. from the element wise norms the 2-norm is computed.\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Manifolds.flat-Tuple{ProductManifold,Vararg{Any,N} where N}","page":"Product manifold","title":"Manifolds.flat","text":"flat(M::ProductManifold, x, w::FVector{TangentSpaceType})\n\nuse the musical isomorphism to transform the tangent vector w from the tangent space at x on the ProductManifold M to a cotangent vector. This can be done elementwise, so for every entry of w (and x) sparately\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Manifolds.sharp-Tuple{ProductManifold,Vararg{Any,N} where N}","page":"Product manifold","title":"Manifolds.sharp","text":"sharp(M::ProductManifold, x, w::FVector{CotangentSpaceType})\n\nUse the musical isomorphism to transform the cotangent vector w from the tangent space at x on the ProductManifold M to a tangent vector. This can be done elementwise, so vor every entry of w (and x) sparately\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Manifolds.submanifold-Tuple{ProductManifold,Integer}","page":"Product manifold","title":"Manifolds.submanifold","text":"submanifold(M::ProductManifold, i::Integer)\n\nExtract the ith factor of the product manifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Manifolds.submanifold-Tuple{ProductManifold,Val}","page":"Product manifold","title":"Manifolds.submanifold","text":"submanifold(M::ProductManifold, i::Val)\nsubmanifold(M::ProductManifold, i::AbstractVector)\n\nExtract the factor of the product manifold M indicated by indices in i. For example, for i equal to Val((1, 3)) the product manifold constructed from the first and the third factor is returned.\n\nThe version with AbstractVector is not type-stable, for better preformance use Val.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#ManifoldsBase.distance-Tuple{ProductManifold,Any,Any}","page":"Product manifold","title":"ManifoldsBase.distance","text":"distance(M::ProductManifold, x, y)\n\ncompute the distance two points x and y on the ProductManifold M, which is the 2-norm of the elementwise distances on the internal manifolds that build M.\n\n\n\n","category":"method"},{"location":"manifolds/product.html#ManifoldsBase.injectivity_radius-Tuple{ProductManifold,Vararg{Any,N} where N}","page":"Product manifold","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::ProductManifold[, x])\n\nCompute the injectivity radius on the ProductManifold, which is the minimum of the factor manifolds.\n\n\n\n","category":"method"},{"location":"manifolds/product.html#ManifoldsBase.inner-Tuple{ProductManifold,Any,Any,Any}","page":"Product manifold","title":"ManifoldsBase.inner","text":"inner(M::ProductManifold, x, v, w)\n\ncompute the inner product of two tangent vectors v, w from the tangent space at x on the ProductManifold M, which is just the sum of the internal manifolds that build M.\n\n\n\n","category":"method"},{"location":"manifolds/product.html#ManifoldsBase.inverse_retract-Tuple{ProductManifold,Any,Any,Any,Manifolds.InverseProductRetraction}","page":"Product manifold","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::ProductManifold, x, y, m::InverseProductRetraction)\n\nCompute the inverse retraction from x with respect to y on the ProductManifold M using an InverseProductRetraction, which by default encapsulates a inverse retraction for each manifold of the product. Then this method is performed elementwise, so the encapsulated inverse retraction methods have to be available per factor.\n\n\n\n","category":"method"},{"location":"manifolds/product.html#ManifoldsBase.manifold_dimension-Tuple{ProductManifold}","page":"Product manifold","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::ProductManifold)\n\nReturn the manifold dimension of the ProductManifold, which is the sum of the manifold dimensions the product is made of.\n\n\n\n","category":"method"},{"location":"manifolds/product.html#ManifoldsBase.retract-Tuple{ProductManifold,Vararg{Any,N} where N}","page":"Product manifold","title":"ManifoldsBase.retract","text":"retract(M::ProductManifold, x, v, m::ProductRetraction)\n\nCompute the retraction from x with tangent vector v on the ProductManifold M using an ProductRetraction, which by default encapsulates retractions of the base manifolds. Then this method is performed elementwise, so the encapsulated retractions method has to be one that is available on the manifolds.\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Manifolds.InverseProductRetraction","page":"Product manifold","title":"Manifolds.InverseProductRetraction","text":"InverseProductRetraction(retractions::AbstractInverseRetractionMethod...)\n\nProduct inverse retraction of inverse retractions. Works on ProductManifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/product.html#Manifolds.ProductFVectorDistribution","page":"Product manifold","title":"Manifolds.ProductFVectorDistribution","text":"ProductFVectorDistribution([type::VectorBundleFibers], [x], distrs...)\n\nGenerates a random vector at point x from vector space (a fiber of a tangent bundle) of type type using the product distribution of given distributions.\n\nVector space type and x can be automatically inferred from distributions distrs.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/product.html#Manifolds.ProductPointDistribution","page":"Product manifold","title":"Manifolds.ProductPointDistribution","text":"ProductPointDistribution(M::ProductManifold, distributions)\n\nProduct distribution on manifold M, combined from distributions.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/product.html#Manifolds.ProductRetraction","page":"Product manifold","title":"Manifolds.ProductRetraction","text":"ProductRetraction(retractions::AbstractRetractionMethod...)\n\nProduct retraction of retractions. Works on ProductManifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/product.html#LinearAlgebra.cross-Tuple{Vararg{Manifold,N} where N}","page":"Product manifold","title":"LinearAlgebra.cross","text":"cross(M,N)\ncross(M1, M2, M3,...)\n\nReturn the ProductManifold For two Manifolds M and N, where for the case that one of them is a ProductManifold itself, the other is either prepended (if N is a product) or appenden (if M) is. If both are product manifold, they are combined into one product manifold, keeping the order.\n\nFor the case that more than one is a product manifold of these is build with the same approach as above\n\n\n\n","category":"method"},{"location":"manifolds/product.html#ManifoldsBase.check_manifold_point-Tuple{ProductManifold,ProductRepr}","page":"Product manifold","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::ProductManifold, x; kwargs...)\n\nCheck whether x is a valid point on the ProductManifold M.\n\nThe tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#ManifoldsBase.check_tangent_vector-Tuple{ProductManifold,ProductRepr,ProductRepr}","page":"Product manifold","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::ProductManifold, x, v; kwargs... )\n\nCheck whether v is a tangent vector to x on the ProductManifold M, i.e. atfer check_manifold_point(M, x), and all projections to base manifolds must be respective tangent vectors.\n\nThe tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#Euclidean-space-1","page":"Euclidean","title":"Euclidean space","text":"","category":"section"},{"location":"manifolds/euclidean.html#","page":"Euclidean","title":"Euclidean","text":"The Euclidean space mathbb R^n is a simple model space, since it has curvature constantly zero everywhere; hence, nearly all operations simplify.","category":"page"},{"location":"manifolds/euclidean.html#","page":"Euclidean","title":"Euclidean","text":"Modules = [Manifolds]\nPages = [\"manifolds/Euclidean.jl\"]\nOrder = [:type,:function]","category":"page"},{"location":"manifolds/euclidean.html#Manifolds.Euclidean","page":"Euclidean","title":"Manifolds.Euclidean","text":"Euclidean{T<:Tuple} <: Manifold\n\nEuclidean vector space mathbb R^n.\n\nConstructor\n\nEuclidean(n)\n\nGenerate the n-dimensional vector space mathbb R^n.\n\nEuclidean(nâ‚,nâ‚‚,...,náµ¢; field=â„)\n\nGenerate the vector space of k=n_1n_2cdotldots n_i values, i.e. the mathbb F^n_1 n_2 ldots n_d whose elements are interpreted as n_1 timesn_2timescdotstimes n_i arrays. For d=2 we obtain a matrix space. The default field=â„ can also be set to field=â„‚. The dimension of this space is k dim_â„ ð”½, where dim_â„ ð”½ is the real_dimension of the field ð”½.\n\n\n\n","category":"type"},{"location":"manifolds/euclidean.html#Manifolds.EuclideanMetric","page":"Euclidean","title":"Manifolds.EuclideanMetric","text":"EuclideanMetric <: RiemannianMetric\n\nA general type for any manifold that employs the Euclidean Metric, for example the Euclidean manifold itself, or the Sphere, where every tangent space (as a plane in the embedding) uses this metric (in the embedding).\n\nSince the metric is independent of the field type, this metric is also used for the Hermitian metrics, i.e. metrics that are analogous to the EuclideanMetric but where the field type of the manifold is â„‚.\n\nThis metric is the default metric for example for the Euclidean manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/euclidean.html#Base.exp-Tuple{Euclidean,Vararg{Any,N} where N}","page":"Euclidean","title":"Base.exp","text":"exp(M::Euclidean, x, v)\n\nCompute the exponential map on the Euclidean manifold M from x in direction v, which in this case is just\n\nexp_x v = x + v\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#Base.log-Tuple{Euclidean,Vararg{Any,N} where N}","page":"Euclidean","title":"Base.log","text":"log(M::Euclidean, x, y)\n\nCompute the logarithmic map on the Euclidean M from x to y, which in this case is just\n\nlog_x y = y - x\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#LinearAlgebra.norm-Tuple{Euclidean,Any,Any}","page":"Euclidean","title":"LinearAlgebra.norm","text":"norm(M::Euclidean, x, v)\n\nCompute the norm of a tangent vector v at x on the Euclidean M, i.e. since every tangent space can be identified with M itself in this case, just the (Frobenius) norm of v.\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#Manifolds.flat-Tuple{Euclidean,Vararg{Any,N} where N}","page":"Euclidean","title":"Manifolds.flat","text":"flat(M::Euclidean, x, w)\n\nTransform a tangent vector into a cotangent. Since they can directly be identified in the Euclidean case, this yields just the identity for a tangent vector w in the tangent space of x on M. The result is returned also in place in v.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#Manifolds.normal_tvector_distribution-Union{Tuple{N}, Tuple{Euclidean{Tuple{N},T} where T,Any,Any}} where N","page":"Euclidean","title":"Manifolds.normal_tvector_distribution","text":"normal_tvector_distribution(M::Euclidean, x, Ïƒ)\n\nNormal distribution in ambient space with standard deviation Ïƒ projected to tangent space at x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#Manifolds.projected_distribution-Tuple{Euclidean,Any,Any}","page":"Euclidean","title":"Manifolds.projected_distribution","text":"projected_distribution(M::Euclidean, d, [x])\n\nWrap the standard distribution d into a manifold-valued distribution. Generated points will be of similar type to x. By default, the type is not changed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#Manifolds.sharp-Tuple{Euclidean,Vararg{Any,N} where N}","page":"Euclidean","title":"Manifolds.sharp","text":"sharp(M::Euclidean, x, w)\n\nsince cotangent and tangent vectors can directly be identified in the Euclidean case, this yields just the identity for a cotangent vector w in the tangent space of x on M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.distance-Tuple{Euclidean,Any,Any}","page":"Euclidean","title":"ManifoldsBase.distance","text":"distance(M::Euclidean, x, y)\n\nCompute the Euclidean distance between two points on the Euclidean manifold M, i.e. for vectors it's just the norm of the difference, for matrices and higher order arrays, the matrix and ternsor Frobenius norm, respectively.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.injectivity_radius-Tuple{Euclidean}","page":"Euclidean","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::Euclidean)\n\nReturn the injectivity radius on the Euclidean M, which is infty.\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.inner-Tuple{Euclidean,Vararg{Any,N} where N}","page":"Euclidean","title":"ManifoldsBase.inner","text":"inner(M::Euclidean, x, v, w)\n\nCompute the inner product on the Euclidean M, which is just the inner product on the real-valued or complex valued vector space of arrays (or tensors) of size n_1times n_2 times cdots times n_i, i.e.\n\ng_x(vw) = sum_kin I overlinev_k w_k\n\nwhere I is the set of integer vectors kinmathbb N^i, such that for all 1 leq j leq i it holds 1leq k_j leq n_j.\n\nFor the special case of ileq 2, i.e. matrices and vectors, this simplifies to\n\ng_x(vw) = w^mathrmHv\n\nwhere cdot^mathrmH denotes the hermitian, i.e. complex conjugate transposed.\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.manifold_dimension-Union{Tuple{Euclidean{N,ð”½}}, Tuple{ð”½}, Tuple{N}} where ð”½ where N","page":"Euclidean","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::Euclidean)\n\nReturn the manifold dimension of the Euclidean M, i.e. the product of all array dimensions and the real_dimension of the underlying number system.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.project_point-Tuple{Euclidean,Vararg{Any,N} where N}","page":"Euclidean","title":"ManifoldsBase.project_point","text":"project_point(M::Euclidean, x)\n\nProject an arbitrary point x onto the Euclidean M, which is of course just the identity map.\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.project_tangent-Tuple{Euclidean,Vararg{Any,N} where N}","page":"Euclidean","title":"ManifoldsBase.project_tangent","text":"project_tangent(M::Euclidean, x, v)\n\nProject an arbitrary vector v into the tangent space of a point x on the Euclidean M, which is just the identity, since any tangent space of M can be identified with all of M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.representation_size-Union{Tuple{Euclidean{N,T} where T}, Tuple{N}} where N","page":"Euclidean","title":"ManifoldsBase.representation_size","text":"representation_size(M::Euclidean)\n\nReturn the array dimensions required to represent an element on the Euclidean M, i.e. the vector of all array dimensions.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.vector_transport_to-Tuple{Euclidean,Any,Any,Any,ParallelTransport}","page":"Euclidean","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::Euclidean, x, v, y, ::ParallelTransport)\n\nParallely transport the vector v from the tangent space at x to the tangent space at y on the Euclidean M, which simplifies to the identity.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.zero_tangent_vector-Tuple{Euclidean,Vararg{Any,N} where N}","page":"Euclidean","title":"ManifoldsBase.zero_tangent_vector","text":"zero_tangent_vector(M::Euclidean, x)\n\nReturn the zero vector in the tangent space of x on the Euclidean M, which here is just a zero filled array the same size as x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices.html#Fixed-rank-matrices-1","page":"Fixed-rank matrices","title":"Fixed-rank matrices","text":"","category":"section"},{"location":"manifolds/fixedrankmatrices.html#","page":"Fixed-rank matrices","title":"Fixed-rank matrices","text":"Modules = [Manifolds]\nPages = [\"FixedRankMatrices.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/fixedrankmatrices.html#Manifolds.FixedRankMatrices","page":"Fixed-rank matrices","title":"Manifolds.FixedRankMatrices","text":"FixedRankMatrices{m,n,k,T} <: Manifold\n\nThe manifold of mtimes n real-valued (complex-valued) matrices of fixed rank k, i.e.\n\nmathcal M =  x in mathbb R^mtimes n  operatornamerank(x) = kÂ \n\nRepresentation with 3 matrix factors\n\nA point xinmathcal M can be stored using orthonormal matrices Uinmathbb R^mtimes k, Vinmathbb R^ntimes k as well as the k singular values of x = USV^mathrmT. In other words, U and V are from the manifolds Stiefel(m,k) and Stiefel(n,k), respectively; see SVDMPoint for details\n\nThe tangent space T_xmathcal M at a point xinmathcal M with x=USV^mathrmT is given by\n\nT_xmathcal M = bigl UMV^mathrmT + U_xV^mathrmT + UV_x^mathrmT \n    M in mathbb R^ktimes k\n    U_x in mathbb R^mtimes k\n    V_x in mathbb R^ntimes k\n    text st \n    U_x^mathrmTU = 0_k\n    V_x^mathrmTV = 0_k\nbigr\n\nwhere 0_k is the ktimes k zero matrix. See UMVTVector for details.\n\nThe (default) metric of this manifold is obtained by restricting the metric on mathbb R^mtimes n to the tangent bundle. This implementation follows[Vandereycken2013].\n\nConstructor\n\nFixedRankMatrics(m,n,k,t=â„)\n\nGenerate the manifold of m-by-n real-valued matrices of rank k.\n\n[Vandereycken2013]: Bart Vandereycken: \"Low-rank matrix completion by Riemannian Optimization, SIAM Journal on Optiomoization, 23(2), pp. 1214â€“1236, 2013. doi: 10.1137/110845768, arXiv: 1209.3834.\n\n\n\n","category":"type"},{"location":"manifolds/fixedrankmatrices.html#Manifolds.SVDMPoint","page":"Fixed-rank matrices","title":"Manifolds.SVDMPoint","text":"SVDMPoint <: MPoint\n\nA point on a certain manifold, where the data is stored in a svd like fashion, i.e. in the form USV^mathrmT, where this structure stores U, S and V^mathrmT. The storage might also be shortened to just k singular values and accordingly shortened U (columns) and V^mathrmT (rows)\n\nConstructors\n\nSVDMPoint(A) for a matrix A, stores its svd factors (i.e. implicitly k=minmn)\nSVDMPoint(S) for an SVD object, stores its svd factors (i.e. implicitly k=minmn)\nSVDMPoint(U,S,Vt) for the svd factors to initialize the SVDMPoint` (i.e. implicitly k=minmn)\nSVDMPoint(A,k) for a matrix A, stores its svd factors shortened to the best rank k approximation\nSVDMPoint(S,k) for an SVD object, stores its svd factors shortened to the best rank k approximation\nSVDMPoint(U,S,Vt,k) for the svd factors to initialize the SVDMPoint, stores its svd factors shortened to the best rank k approximation\n\n\n\n","category":"type"},{"location":"manifolds/fixedrankmatrices.html#Manifolds.UMVTVector","page":"Fixed-rank matrices","title":"Manifolds.UMVTVector","text":"UMVTVector <: TVector\n\nA tangent vector that can be described as a product UMV^mathrmT, at least together with its base point, see for example FixedRankMatrices\n\nConstructors\n\nUMVTVector(U,M,Vt) store umv factors to initialize the UMVTVector\nUMVTVector(U,M,Vt,k) store the umv factors after shortening them down to inner dimensions k, i.e. in UMV^mathrmT, Minmathbb R^ktimes k\n\n\n\n","category":"type"},{"location":"manifolds/fixedrankmatrices.html#ManifoldsBase.inner-Tuple{FixedRankMatrices,SVDMPoint,UMVTVector,UMVTVector}","page":"Fixed-rank matrices","title":"ManifoldsBase.inner","text":"inner(M::FixedRankMatrices, x::SVDMPoint, v::UMVTVector, w::UMVTVector)\n\nCompute the inner product of v and w in the tangent space of x on the FixedRankMatrices M, which is inherited from the embedding, i.e. can be computed using dot on the elements (U, Vt, M) of v and w.\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices.html#ManifoldsBase.manifold_dimension-Union{Tuple{FixedRankMatrices{m,n,k,ð”½}}, Tuple{ð”½}, Tuple{k}, Tuple{n}, Tuple{m}} where ð”½ where k where n where m","page":"Fixed-rank matrices","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::FixedRankMatrices{m,n,k,ð”½})\n\nReturn the manifold dimension for the ð”½-valued FixedRankMatrices M of dimension mxn of rank k, namely\n\nk(m + n - k) dim_â„ ð”½\n\nwhere dim_â„ ð”½ is the real_dimension of ð”½.\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices.html#ManifoldsBase.project_tangent-Tuple{FixedRankMatrices,Vararg{Any,N} where N}","page":"Fixed-rank matrices","title":"ManifoldsBase.project_tangent","text":"project_tangent(M, x, A)\nproject_tangent(M, x, v)\n\nProject the matrix Ainmathbb R^mn or a UMVTVector v from the embedding or another tangent space onto the tangent space at x on the FixedRankMatrices M, further decomposing the result into v=UMV, i.e. a UMVTVector following Section 3 in [Vandereycken2013].\n\n[Vandereycken2013]: Bart Vandereycken: \"Low-rank matrix completion by Riemannian Optimization, SIAM Journal on Optiomoization, 23(2), pp. 1214â€“1236, 2013. doi: 10.1137/110845768, arXiv: 1209.3834.\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices.html#ManifoldsBase.representation_size-Union{Tuple{FixedRankMatrices{m,n,K,T} where T where K}, Tuple{n}, Tuple{m}} where n where m","page":"Fixed-rank matrices","title":"ManifoldsBase.representation_size","text":"representation_size(M::FixedRankMatrices{m,n,k})\n\nReturn the element size of a point on the FixedRankMatrices M, i.e. the size of matrices on this manifold (mn).\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices.html#ManifoldsBase.retract-Tuple{FixedRankMatrices,Any,Any,PolarRetraction}","page":"Fixed-rank matrices","title":"ManifoldsBase.retract","text":"retract(M, x, v, ::PolarRetraction)\n\nCompute an SVD-based retraction on the FixedRankMatrices M by computing\n\n    y = U_kS_kV_k^mathrmT\n\nwhere U_k S_k V_k^mathrmT is the shortened singular value decomposition USV=x+v, in the sense that S_k is the diagonal matrix of size ktimes k with the k largest singular values and U and V are shortened accordingly.\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices.html#ManifoldsBase.zero_tangent_vector-Union{Tuple{k}, Tuple{n}, Tuple{m}, Tuple{FixedRankMatrices{m,n,k,T} where T,SVDMPoint}} where k where n where m","page":"Fixed-rank matrices","title":"ManifoldsBase.zero_tangent_vector","text":"zero_tangent_vector(M::FixedRankMatrices, x::SVDMPoint)\n\nReturn a UMVTVector representing the zero tangent vector in the tangent space of x on the FixedRankMatrices M, for example all three elements of the resulting structure are zero matrices.\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices.html#ManifoldsBase.check_manifold_point-Union{Tuple{k}, Tuple{n}, Tuple{m}, Tuple{FixedRankMatrices{m,n,k,T} where T,Any}} where k where n where m","page":"Fixed-rank matrices","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::FixedRankMatrices{m,n,k},x; kwargs...)\n\nCheck whether the matrix or SVDMPoint x ids a valid point on the FixedRankMatrices{m,n,k} M, i.e. is (or represents) an m-byn matrix of rank k. For the SVDMPoint the internal representation also has to have the right shape, i.e. x.U and x.Vt have to be unitary.\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices.html#ManifoldsBase.check_tangent_vector-Union{Tuple{k}, Tuple{n}, Tuple{m}, Tuple{FixedRankMatrices{m,n,k,T} where T,SVDMPoint,UMVTVector}} where k where n where m","page":"Fixed-rank matrices","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M:FixedRankMatrices{m,n,k}, x, v)\n\nCheck whether the tangent UMVTVector v is from the tangent space of the SVDMPoint x on the FixedRankMatrices M, i.e. that v.U and v.Vt are (columnwise) orthogonal to x.U and x.Vt, respectively, and its dimensions are consistent with x and M, i.e. correspond to m-by-n matrices of rank k.\n\n\n\n","category":"method"},{"location":"manifolds/fixedrankmatrices.html#Literature-1","page":"Fixed-rank matrices","title":"Literature","text":"","category":"section"},{"location":"manifolds/stiefel.html#Stiefel-1","page":"Stiefel","title":"Stiefel","text":"","category":"section"},{"location":"manifolds/stiefel.html#","page":"Stiefel","title":"Stiefel","text":"Modules = [Manifolds]\nPages = [\"manifolds/Stiefel.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/stiefel.html#Manifolds.Stiefel","page":"Stiefel","title":"Manifolds.Stiefel","text":"Stiefel{n,k,T} <: Manifold\n\nThe Stiefel manifold consists of all ntimes k, ngeq k orthonormal matrices, i.e.\n\nmathcal M =  x in mathbb F^ntimes k  x^mathrmHx = I_k \n\nwhere mathbb F in mathbb R mathbb C, cdot^mathrmH denotes the complex conjugate transpose or Hermitian, and I_n in mathbb R^ntimes n denotes the k times k identity matrix.\n\nThe tangent space at a point xinmathcal M is given by\n\nT_xmathcal M =  v in mathbbF^ntimes k  x^mathrmHv + v^mathrmHx=0_n\n\nwhere 0_n is the ktimes k zero matrix.\n\nThe metric is either inherited from mathbb R^nk for the real-valued case or the one inherited from interpreting the complex valued entries in the Gaussian plane mathbb R^2 and then over all entries as before, i.e. the latter may be called an Hermitian metric in the complex-valued matrices.\n\nThe manifold is named after Eduard L. Stiefel (1909â€“1978).\n\nConstructor\n\nStiefel(n,k,F=â„)\n\nGenerate the (real-valued) Stiefel manifold of ntimes k dimensional orthonormal matrices.\n\n\n\n","category":"type"},{"location":"manifolds/stiefel.html#Base.exp-Tuple{Stiefel,Vararg{Any,N} where N}","page":"Stiefel","title":"Base.exp","text":"exp(M, x, v)\n\nCompute the exponential map on the Stiefel{n,k,T}() manifold M eminating from x into tangent direction v.\n\noperatornameexp_x v = beginpmatrix\n   xv\n endpmatrix\n exp\n left(\n beginpmatrix x^mathrmHv  - v^mathrmHv\n I_n  x^mathrmHvendpmatrix\n right)\nbeginpmatrix  exp( -x^mathrmHv)  0_nendpmatrix\n\nwhere exp denotes matrix exponential, cdot^mathrmH denotes the complex conjugate transpose or Hermitian, and I_k and 0_k are the identity matrix and the zero matrix of dimension k times k, respectively.\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.inner-Tuple{Stiefel,Any,Any,Any}","page":"Stiefel","title":"ManifoldsBase.inner","text":"inner(M::Stiefel, x, v, w)\n\nCompute the inner product for two tangent vectors v, w from the tangent space of x on the Stiefel manifold M. The formula reads\n\n(vw)_x = operatornametrace(v^mathrmHw)\n\ni.e. the EuclideanMetric from the embedding restricted to the tangent space. For the complex-valued case this is the Hermitian metric, to be precise.\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.inverse_retract-Tuple{Stiefel,Vararg{Any,N} where N}","page":"Stiefel","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::Stiefel, x, y, ::PolarInverseRetraction)\n\nCompute the inverse retraction based on a singular value decomposition for two points x, y on the Stiefel manifold M and return the resulting tangent vector in v. This follows the folloing approach: From the Polar retraction we know that\n\noperatornameretr_x^-1(y) = ys - q\n\nif such a symmetric positive definite ktimes k matrix exists. Since ys-q is also a tangent vector at x we obtain\n\nx^mathrmHys + s(x^mathrmHy)^mathrmH + 2I_k = 0\n\nwhich can either be solved by a Lyapunov approach or a continuous-time algebraic Riccati equation as described in [KanekoFioriTanaka2013]\n\nThis implementation follows the Lyapunov approach.\n\ninverse_retract(M, x, y, ::QRInverseRetraction)\n\nCompute the inverse retraction based on a qr decomposition for two points x, y on the Stiefel manifold M and return the resulting tangent vector in v. The computation follows Algorithm 1 in [KanekoFioriTanaka2013].\n\n[KanekoFioriTanaka2013]: T. Kaneko, S. Fiori, T. Tanaka: \"Empirical Arithmetic Averaging over the Compact Stiefel Manifold\", IEEE Transactions on Signal Processing, 2013, doi: 10.1109/TSP.2012.2226167.\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.manifold_dimension-Union{Tuple{Stiefel{n,k,â„}}, Tuple{k}, Tuple{n}} where k where n","page":"Stiefel","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::Stiefel)\n\nReturn the dimension of the Stiefel manifold M=operatornameSt(nkð”½). The dimension is given by\n\ndim mathrmStiefel(n k â„) = nk - frac12k(k+1)\ndim mathrmStiefel(n k â„‚) = 2nk - k^2\ndim mathrmStiefel(n k â„) = 4nk - k(2k-1)\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.project_tangent-Tuple{Stiefel,Vararg{Any,N} where N}","page":"Stiefel","title":"ManifoldsBase.project_tangent","text":"project_tangent(M, x, v)\n\nProject v onto the tangent space of x to the Stiefel manifold M. The formula reads\n\noperatornameproj_mathcal M(xv) = v - x operatornameSym(x^mathrmHv)\n\nwhere operatornameSym(y) is the symmetrization of y, e.g. by operatornameSym(y) = fracy^mathrmH+y2.\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.representation_size-Union{Tuple{Stiefel{n,k,F} where F}, Tuple{k}, Tuple{n}} where k where n","page":"Stiefel","title":"ManifoldsBase.representation_size","text":"representation_size(M::Stiefel)\n\nReturns the representation size of the Stiefel M=operatornameSt(nk), i.e. (n,k), which is the matrix dimensions.\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.retract-Tuple{Stiefel,Vararg{Any,N} where N}","page":"Stiefel","title":"ManifoldsBase.retract","text":"retract(M, x, v, ::PolarRetraction)\n\nCompute the SVD-based retraction PolarRetraction on the Stiefel manifold M. With USV = x + v the retraction reads\n\noperatornameretr_x(v) = UbarV^mathrmH\n\nretract(M, x, v, ::QRRetraction )\n\nCompute the QR-based retraction QRRetraction on the Stiefel manifold M. With QR = x + v the retraction reads\n\noperatornameretr_x(v) = QD\n\nwhere D is a ntimes k matrix with\n\nD = operatornamediagbigl(operatornamesgn(R_ii+05)_i=1^k bigr)\n\nwhere operatornamesgn(x) = begincases 1  text for  x  0\n0  text for  x = 0\n-1 text for  x  0 endcases\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.zero_tangent_vector-Tuple{Stiefel,Vararg{Any,N} where N}","page":"Stiefel","title":"ManifoldsBase.zero_tangent_vector","text":"zero_tangent_vector(M::Stiefel, x)\n\nReturns the zero tangent vector from the tangent space at x on the Stiefel M=operatornameSt(nk), i.e. an (n,k) zero matrix.\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.check_manifold_point-Union{Tuple{T}, Tuple{k}, Tuple{n}, Tuple{Stiefel{n,k,T},Any}} where T where k where n","page":"Stiefel","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::Stiefel, x; kwargs...)\n\nCheck whether x is a valid point on the Stiefel M=operatornameSt(nk), i.e. that it has the right AbstractNumbers type and x^mathrmHx is (approximatly) the identity, where cdot^mathrmH is the complex conjugate transpose. The settings for approximately can be set with kwargs....\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#ManifoldsBase.check_tangent_vector-Union{Tuple{T}, Tuple{k}, Tuple{n}, Tuple{Stiefel{n,k,T},Any,Any}} where T where k where n","page":"Stiefel","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::Stiefel, x, v; kwargs...)\n\nCheck whether v is a valid tangent vector at x on the Stiefel M=operatornameSt(nk), i.e. the AbstractNumbers fits and it (approximtly) holds that x^mathrmHv + v^mathrmHx = 0, where kwargs... is passed to the isapprox.\n\n\n\n","category":"method"},{"location":"manifolds/stiefel.html#Literature-1","page":"Stiefel","title":"Literature","text":"","category":"section"},{"location":"manifolds/stiefel.html#","page":"Stiefel","title":"Stiefel","text":"<ul>\n<li id=\"SatoTawi2013\">\nH. Sato and T. Iawi, â€œA complex singular value decomposition algorithm based on\nthe Riemannian Newton methodâ€, in: <emph>IEEE 52nd Annual Conference on Decision and\nControl (CDC)</emph>, 2013, p. 2972--2978,\ndoi: <a href=\"https://doi.org/10.1109/CDC.2013.6760335\">10.1109/CDC.2013.6760335</a>\n</li>\n<li>\nH. Sato: â€œRiemannian conjugate gradient method for complex singular value\ndecomposition problemâ€, in: <emph>IEEE 53rd Annual COnference on Decision and Control\n(CDC)</emph>, 2014, p. 5849â€“5854,\ndoi: <a href=\"https://doi.org/10.1109/CDC.2014.7040305\">10.1109/CDC.2014.7040305</a>\n</li>","category":"page"},{"location":"manifolds/circle.html#Circle-1","page":"Circle","title":"Circle","text":"","category":"section"},{"location":"manifolds/circle.html#","page":"Circle","title":"Circle","text":"Modules = [Manifolds]\nPages = [\"manifolds/Circle.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/circle.html#Manifolds.Circle","page":"Circle","title":"Manifolds.Circle","text":"Circle{F} <: Manifold\n\nThe circle mathbb S^1 as a manifold ere manifold represented by real-valued data in -pipi) or complex-valued data zin mathbb C of absolute value lvert zrvert = 1.\n\nConstructor\n\nCircle(f=â„)\n\nGenerate the â„-valued Circle represented by angles, which alternatively can be set to use the AbstractNumbers f=â„‚ to obtain the Circle represented by â„‚-valued Circle of unit numbers.\n\n\n\n","category":"type"},{"location":"manifolds/circle.html#Base.exp-Tuple{Circle,Vararg{Any,N} where N}","page":"Circle","title":"Base.exp","text":"exp(M::Circle, x, v)\n\nCompute the exponential map on the Circle.\n\nexp_xv = (x+v)_2pi\n\nwhere (cdot) is the (symmetric) remainder with respect to division by 2pi, i.e. in -pipi).\n\nFor the complex-valued case the formula is the same as for the Sphere applied to valuedin the complex plane.\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#Base.log-Tuple{Circle,Vararg{Any,N} where N}","page":"Circle","title":"Base.log","text":"log(M::Circle, x, y)\n\nCompute the logarithmic map on the Circle M.\n\nexp_xv = (yx)_2pi\n\nwhere (cdot) is the (symmetric) remainder with respect to division by 2pi, i.e. in -pipi).\n\nFor the complex-valued case the formula is the same as for the Sphere applied to valuedin the complex plane.\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#Manifolds.complex_dot-Tuple{Any,Any}","page":"Circle","title":"Manifolds.complex_dot","text":"complex_dot(a, b)\n\nCompute the inner product of two (complex) numbers with in the complex plane.\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#Manifolds.get_coordinates-Tuple{Circle{â„‚},Any,Any,ArbitraryOrthonormalBasis}","page":"Circle","title":"Manifolds.get_coordinates","text":"get_coordinates(M::Circle{â„‚}, x, v, B::ArbitraryOrthonormalBasis)\n\nReturn tangent vector coordinates in the Lie algebra of the circle.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#Manifolds.get_vector-Tuple{Circle{â„‚},Any,Any,ArbitraryOrthonormalBasis}","page":"Circle","title":"Manifolds.get_vector","text":"get_vector(M::Circle{â„‚}, x, v, B::ArbitraryOrthonormalBasis)\n\nReturn tangent vector from the coordinates in the Lie algebra of the circle.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#Manifolds.sym_rem-Union{Tuple{N}, Tuple{N}, Tuple{N,Any}} where N<:Number","page":"Circle","title":"Manifolds.sym_rem","text":"sym_rem(x,[T=Ï€])\n\nCompute symmetric remainder of x with respect to the interall 2*T, i.e. (x+T)%2T, where the default for T is pi\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#ManifoldsBase.distance-Tuple{Circle,Vararg{Any,N} where N}","page":"Circle","title":"ManifoldsBase.distance","text":"distance(M::Circle, x, y)\n\nCompute the distance on the Circle M, which is the absolute value of the symmetric remainder of x and y for the real-valued case and the angle between both complex numbers in the Gaussian plane for the complex-valued case.\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#ManifoldsBase.injectivity_radius-Tuple{Circle,Vararg{Any,N} where N}","page":"Circle","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::Circle[, x])\n\nReturn the injectivity radius on the Circle M, i.e. pi.\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#ManifoldsBase.inner-Tuple{Circle,Vararg{Any,N} where N}","page":"Circle","title":"ManifoldsBase.inner","text":"inner(M::Circle, x, w, v)\n\nCompute the inner product of the two tangent vectors w,v from the tangent plane at x on the Circle M using the restriction of the metric from the embedding, i.e.\n\ng_x(vw) = w*v\n\nfor the real case and\n\ng_x(vw) = v^mathrmTw\n\nfor the complex case interpreting complex numbers in the Gaussian plane.\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#ManifoldsBase.manifold_dimension-Tuple{Circle}","page":"Circle","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::Circle)\n\nReturn the dimension of the Circle M, i.e. operatornamedim(mathbb S^1) = 1.\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#ManifoldsBase.project_point-Tuple{Circle,Any}","page":"Circle","title":"ManifoldsBase.project_point","text":"project_point(M::Circle, x)\n\nProject a point x onto the Circle M. For the real-valued case this is the remainder with respect to modulus 2pi. For the complex-valued case the result is the projection of x onto the unit circle in the complex plane.\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#ManifoldsBase.project_tangent-Tuple{Circle{â„},Real,Real}","page":"Circle","title":"ManifoldsBase.project_tangent","text":"project_tangent(M::Circle, x, v)\n\nProject a value v onto the tangent space of the point x on the Circle M.\n\nFor the real-valued case this is just the identity. For the complex valued case v is projected onto the line in the complex plane that is parallel to the tangent to x on the unit circle and contains 0.\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#ManifoldsBase.vector_transport_to-Tuple{Circle,Any,Any,Any,ParallelTransport}","page":"Circle","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::Circle, x, v, y, ::ParallelTransport)\n\nCompute the parallel transport of v from the tangent space at x to the tangent space at y on the Circle M. For the real-valued case this results in the identity. For the complex-valud case, the formula is the same as for the Sphere(1) in the complex plane.\n\nP_ygets x(v) = v - fraclangle log_xyvrangle_xd^2_mathbb C(xy)\nbigl(log_xy + log_yx bigr)\n\nwhere log denotes the logarithmic map on M.\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#Statistics.mean-Tuple{Circle,Any}","page":"Circle","title":"Statistics.mean","text":"mean(M::Circle, x::AbstractVector[, w::AbstractWeights])\n\nCompute the Riemannian mean of x on the Circle mathbb S^1 by the wrapped mean, i.e. the remainder of the mean modulo 2Ï€.\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#ManifoldsBase.check_manifold_point-Tuple{Circle,Vararg{Any,N} where N}","page":"Circle","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::Circle, x)\n\nCheck whether x is a point on the Circle M. For the real-valued case, x is an angle and hence it checks that x in -pipi). for the complex-valued case its a unit number, x in mathbb C with lvert x rvert = 1.\n\n\n\n","category":"method"},{"location":"manifolds/circle.html#ManifoldsBase.check_tangent_vector-Tuple{Circle{â„},Vararg{Any,N} where N}","page":"Circle","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::Circle, x, v)\n\nCheck whether v is a tangent vector in the tangent space of x on the Circle M. For the real-valued case represented by angles all v are valid, since the tangent space is the whole real line. For the complex-valued case v has to lie on the line parallel to the tangent line at x in the complex plane, i.e. the inner product is zero.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Symmetric-positive-definite-matrices-1","page":"Symmetric positive definite","title":"Symmetric positive definite matrices","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite.html#","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"The symmetric positive definite matrices","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"mathcal P(n) = bigl A in mathbb R^ntimes n big A = A^mathrmT text and  x^mathrmTAx  0 text for  0neq x inmathbb R^n bigr","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"SymmetricPositiveDefinite","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#Manifolds.SymmetricPositiveDefinite","page":"Symmetric positive definite","title":"Manifolds.SymmetricPositiveDefinite","text":"SymmetricPositiveDefinite{N} <: Manifold\n\nThe manifold of symmetric positive definite matrices, i.e.\n\nmathcal P(n) =\nbigl\nx in mathbb R^ntimes n \nxi^mathrmTxxi  0 text for all  xi in mathbb R^nbackslash0\nbigr\n\nConstructor\n\nSymmetricPositiveDefinite(n)\n\ngenerates the manifold mathcal P(n) subset mathbb R^ntimes n\n\n\n\n","category":"type"},{"location":"manifolds/symmetricpositivedefinite.html#","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"can â€“ for example â€“ be illustrated as ellipsoids:  since the eigen values are all positive they can be taken as lengths of the axes of an ellipsoids while the directions are given by the eigenvectors.","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"(Image: An example set of data)","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"The manifold can be equipped with different metrics","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#Common-and-Metric-Independent-functions-1","page":"Symmetric positive definite","title":"Common and Metric Independent functions","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite.html#","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"Modules = [Manifolds]\nPages = [\"manifolds/SymmetricPositiveDefinite.jl\"]\nOrder = [:function]\n Filter = t -> t !== mean","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.injectivity_radius-Union{Tuple{N}, Tuple{SymmetricPositiveDefinite{N},Vararg{Any,N} where N}} where N","page":"Symmetric positive definite","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::SymmetricPositiveDefinite[, x])\ninjectivity_radius(M::MetricManifold{SymmetricPositiveDefinite,LinearAffineMetric}[, x])\ninjectivity_radius(M::MetricManifold{SymmetricPositiveDefinite,LogCholeskyMetric}[, x])\n\nReturn the injectivity radius of the SymmetricPositiveDefinite. Since M is a Hadamard manifold with respect to the LinearAffineMetric and the LogCholeskyMetric, the injectivity radius is globally infty.\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.manifold_dimension-Union{Tuple{SymmetricPositiveDefinite{N}}, Tuple{N}} where N","page":"Symmetric positive definite","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::SymmetricPositiveDefinite)\n\nreturns the dimension of SymmetricPositiveDefinite M=mathcal P(n) nin mathbb N, i.e.\n\ndim mathcal P(n) = fracn(n+1)2\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.representation_size-Union{Tuple{SymmetricPositiveDefinite{N}}, Tuple{N}} where N","page":"Symmetric positive definite","title":"ManifoldsBase.representation_size","text":"representation_size(M::SymmetricPositiveDefinite)\n\nReturn the size of an array representing an element on the SymmetricPositiveDefinite manifold M, i.e. ntimes n, the size of such a symmetric positive definite matrix on mathcal M = mathcal P(n).\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.zero_tangent_vector-Tuple{SymmetricPositiveDefinite,Any}","page":"Symmetric positive definite","title":"ManifoldsBase.zero_tangent_vector","text":"zero_tangent_vector(M::SymmetricPositiveDefinite,x)\n\nreturns the zero tangent vector in the tangent space of the symmetric positive definite matrix x on the SymmetricPositiveDefinite manifold M.\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.check_manifold_point-Union{Tuple{N}, Tuple{SymmetricPositiveDefinite{N},Any}} where N","page":"Symmetric positive definite","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::SymmetricPositiveDefinite, x; kwargs...)\n\nchecks, whether x is a valid point on the SymmetricPositiveDefinite M, i.e. is a matrix of size (N,N), symmetric and positive definite. The tolerance for the second to last test can be set using the kwargs....\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.check_tangent_vector-Union{Tuple{N}, Tuple{SymmetricPositiveDefinite{N},Any,Any}} where N","page":"Symmetric positive definite","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::SymmetricPositiveDefinite, x, v; kwargs... )\n\nCheck whether v is a tangent vector to x on the SymmetricPositiveDefinite M, i.e. atfer check_manifold_point(M,x), v has to be of same dimension as x and a symmetric matrix, i.e. this stores tangent vetors as elements of the corresponding Lie group. The tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Default-Metric:-Linear-Affine-Metric-1","page":"Symmetric positive definite","title":"Default Metric: Linear Affine Metric","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite.html#","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"Modules = [Manifolds]\nPages = [\"manifolds/SymmetricPositiveDefiniteLinearAffine.jl\"]\nOrder = [:type]","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#Manifolds.LinearAffineMetric","page":"Symmetric positive definite","title":"Manifolds.LinearAffineMetric","text":"LinearAffineMetric <: Metric\n\nThe linear affine metric is the metric for symmetric positive definite matrices, that employs matrix logarithms and exponentials, which yields a linear and affine metric.\n\n\n\n","category":"type"},{"location":"manifolds/symmetricpositivedefinite.html#","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"This metric is also the default metric, i.e. any call of the following functions with P=SymmetricPositiveDefinite(3) will result in MetricManifold(P,LinearAffineMetric())and hence yield the formulae described in this seciton.","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"Modules = [Manifolds]\nPages = [\"manifolds/SymmetricPositiveDefiniteLinearAffine.jl\"]\nOrder = [:function]","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#Base.exp-Tuple{SymmetricPositiveDefinite,Vararg{Any,N} where N}","page":"Symmetric positive definite","title":"Base.exp","text":"exp(M::SymmetricPositiveDefinite, x, v)\nexp(M::MetricManifold{SymmetricPositiveDefinite{N},LinearAffineMetric}, x, v)\n\nCompute the exponential map from x with tangent vector v on the SymmetricPositiveDefinite M with its default MetricManifold having the LinearAffineMetric. The formula reads\n\nexp_x v = x^frac12operatornameExp(x^-frac12 v x^-frac12)x^frac12\n\nwhere operatornameExp denotes to the matrix exponential.\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Base.log-Tuple{SymmetricPositiveDefinite,Vararg{Any,N} where N}","page":"Symmetric positive definite","title":"Base.log","text":"log(M::SymmetricPositiveDefinite, x, y)\nlog(M::MetricManifold{SymmetricPositiveDefinite,LinearAffineMetric}, x, y)\n\nCompute the logarithmic map from x to y on the SymmetricPositiveDefinite as a MetricManifold with LinearAffineMetric. The formula reads\n\nlog_x y =\nx^frac12operatornameLog(x^-frac12yx^-frac12)x^frac12\n\nwhere operatornameLog denotes to the matrix logarithm.\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Manifolds.get_basis-Union{Tuple{N}, Tuple{SymmetricPositiveDefinite{N},Any,DiagonalizingOrthonormalBasis}} where N","page":"Symmetric positive definite","title":"Manifolds.get_basis","text":"[Îž,Îº] = get_basis(M::SymmetricPositiveDefinite, x, B::DiagonalizingOrthonormalBasis)\n[Îž,Îº] = get_basis(M::MetricManifold{SymmetricPositiveDefinite{N},LinearAffineMetric}, x, B::DiagonalizingOrthonormalBasis)\n\nReturn a orthonormal basis Îž as a vector of tangent vectors (of length manifold_dimension of M) in the tangent space of x on the MetricManifold of SymmetricPositiveDefinite manifold M with LinearAffineMetric that diagonalizes the curvature tensor R(uv)w with eigenvalues Îº and where the direction B.v has curvature 0.\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.distance-Union{Tuple{N}, Tuple{SymmetricPositiveDefinite{N},Any,Any}} where N","page":"Symmetric positive definite","title":"ManifoldsBase.distance","text":"distance(M::SymmetricPositiveDefinite, x, y)\ndistance(M::MetricManifold{SymmetricPositiveDefinite,LinearAffineMetric})\n\nCompute the distance on the SymmetricPositiveDefinite manifold between x and y, as a MetricManifold with LinearAffineMetric. The formula reads\n\nd_mathcal P(n)(xy)\n= lVert operatornameLog(x^-frac12yx^-frac12)rVert_mathrmF\n\nwhere operatornameLog denotes the matrix logarithm and lVertcdotrVert_mathrmF denotes the matrix Frobenius norm.\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.inner-Tuple{SymmetricPositiveDefinite,Any,Any,Any}","page":"Symmetric positive definite","title":"ManifoldsBase.inner","text":"inner(M::SymmetricPositiveDefinite, x, v, w)\ninner(M::MetricManifold{SymmetricPositiveDefinite,LinearAffineMetric}, x, v, w)\n\nCompute the inner product of v, w in the tangent space of x on the SymmetricPositiveDefinite manifold M, as a MetricManifold with LinearAffineMetric. The formula reads\n\n(v w)_x = operatornametr(x^-1 v x^-1 w)\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.vector_transport_to-Tuple{SymmetricPositiveDefinite,Any,Any,Any,ParallelTransport}","page":"Symmetric positive definite","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::SymmetricPositiveDefinite, x, v, y, ::ParallelTransport)\nvector_transport_to(M::MetricManifold{SymmetricPositiveDefinite,LinearAffineMetric}, x, v, y, ::ParallelTransport)\n\nCompute the parallel transport on the SymmetricPositiveDefinite as a MetricManifold with the LinearAffineMetric. The formula reads\n\nP_ygets x(v) = x^frac12\noperatornameExpbigl(\nfrac12x^-frac12log_x(y)x^-frac12\nbigr)\nx^-frac12v x^-frac12\noperatornameExpbigl(\nfrac12x^-frac12log_x(y)x^-frac12\nbigr)\nx^frac12\n\nwhere operatornameExp denotes the matrix exponential and log the logarithmic map on SymmetricPositiveDefinite (again with respect to the metric mentioned).\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Log-Euclidean-Metric-1","page":"Symmetric positive definite","title":"Log Euclidean Metric","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite.html#","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"Modules = [Manifolds]\nPages = [\"manifolds/SymmetricPositiveDefiniteLogEuclidean.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#Manifolds.LogEuclideanMetric","page":"Symmetric positive definite","title":"Manifolds.LogEuclideanMetric","text":"LogEuclideanMetric <: Metric\n\nThe LogEuclidean Metric consists of the Euclidean metric applied to all elements after mapping them into the Lie Algebra, i.e. performing a matrix logarithm beforehand.\n\n\n\n","category":"type"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.distance-Union{Tuple{N}, Tuple{MetricManifold{SymmetricPositiveDefinite{N},LogEuclideanMetric},Any,Any}} where N","page":"Symmetric positive definite","title":"ManifoldsBase.distance","text":"distance(M::MetricManifold{SymmetricPositiveDefinite{N},LogEuclideanMetric}, x, y)\n\nCompute the distance on the SymmetricPositiveDefinite manifold between x and y as a MetricManifold with LogEuclideanMetric. The formula reads\n\n    d_mathcal P(n)(xy) = lVert Log x - Log y rVert_mathrmF\n\nwhere operatornameLog denotes the matrix logarithm and lVertcdotrVert_mathrmF denotes the matrix Frobenius norm.\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Log-Cholesky-Metric-1","page":"Symmetric positive definite","title":"Log Cholesky Metric","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite.html#","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"Modules = [Manifolds]\nPages = [\"manifolds/SymmetricPositiveDefiniteLogCholesky.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#Manifolds.LogCholeskyMetric","page":"Symmetric positive definite","title":"Manifolds.LogCholeskyMetric","text":"LogCholeskyMetric <: Metric\n\nThe Log-Cholesky metric imposes a metric based on the Cholesky decomposition as introduced by [Lin2019].\n\n[Lin2019]: Lin, Zenhua: \"Riemannian Geometry of Symmetric Positive Definite Matrices via Cholesky Decomposition\", arXiv: 1908.09326.\n\n\n\n","category":"type"},{"location":"manifolds/symmetricpositivedefinite.html#Base.exp-Tuple{MetricManifold{SymmetricPositiveDefinite,LogCholeskyMetric},Vararg{Any,N} where N}","page":"Symmetric positive definite","title":"Base.exp","text":"exp(M::MetricManifold{SymmetricPositiveDefinite,LogCholeskyMetric}, x, v)\n\nCompute the exponential map on the SymmetricPositiveDefinite M with LogCholeskyMetric from x into direction v. The formula reads\n\nexp_x v = (exp_l w)(exp_l w)^mathrmT\n\nwhere exp_lw is the exponential map on CholeskySpace, l is the cholesky decomposition of x, w = l(l^-1vl^-mathrmT)_frac12, and (cdot)_frac12 denotes the lower triangular matrix with the diagonal multiplied by frac12.\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Base.log-Tuple{MetricManifold{SymmetricPositiveDefinite,LogCholeskyMetric},Vararg{Any,N} where N}","page":"Symmetric positive definite","title":"Base.log","text":"log(M::MetricManifold{SymmetricPositiveDefinite,LogCholeskyMetric}, x, y)\n\nCompute the logarithmic map on SymmetricPositiveDefinite M with respect to the LogCholeskyMetric eminating from x to y. The formula can be adapted from the CholeskySpace as\n\nlog_x y = lw^mathrmT + wl^mathrmT\n\nwhere l is the colesky factor of x and w=log_lk for k the cholesky factor of y and the just mentioned logarithmic map is the one on CholeskySpace.\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.distance-Union{Tuple{N}, Tuple{MetricManifold{SymmetricPositiveDefinite{N},LogCholeskyMetric},Any,Any}} where N","page":"Symmetric positive definite","title":"ManifoldsBase.distance","text":"distance(M::MetricManifold{SymmetricPositiveDefinite,LogCholeskyMetric}, x, y)\n\nCompute the distance on the manifold of SymmetricPositiveDefinite nmatrices, i.e. between two symmetric positive definite matrices x and y with respect to the LogCholeskyMetric. The formula reads\n\nd_mathcal P(n)(xy) = sqrt\n lVert lfloor l rfloor - lfloor k rfloor rVert_mathrmF^2\n + lVert log(operatornamediag(l)) - log(operatornamediag(k))rVert_mathrmF^2   \n\nwhere l and k are the cholesky factors of x and y, respectively, lfloorcdotrfloor denbotes the strictly lower triangular matrix of its argument, and lVertcdotrVert_mathrmF denotes the Frobenius norm.\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.inner-Union{Tuple{N}, Tuple{MetricManifold{SymmetricPositiveDefinite{N},LogCholeskyMetric},Any,Any,Any}} where N","page":"Symmetric positive definite","title":"ManifoldsBase.inner","text":"inner(M::MetricManifold{SymmetricPositiveDefinite,LogCholeskyMetric}, x, v, w)\n\nCompute the inner product of two matrices v, w in the tangent space of x on the SymmetricPositiveDefinite manifold M, as a MetricManifold with LogCholeskyMetric. The formula reads\n\n    (vw)_x = (p_l(w)p_l(v))_l\n\nwhere the right hand side is the inner product on the CholeskySpace, l is the cholesky factor of x, p_l(w) = l (l^-1wl^-mathrmT)_frac12, and (cdot)_frac12 denotes the lower triangular matrix with the diagonal multiplied by frac12\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.vector_transport_to-Tuple{MetricManifold{SymmetricPositiveDefinite,LogCholeskyMetric},Any,Any,Any,ParallelTransport}","page":"Symmetric positive definite","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(\n    M::MetricManifold{SymmetricPositiveDefinite,LogCholeskyMetric},\n    x,\n    v,\n    y,\n    ::ParallelTransport,\n)\n\nParallely transport the tangent vector v at x along the geodesic to y with respect to the SymmetricPositiveDefinite manifold M and LogCholeskyMetric. The parallel transport is based on the parallel transport on CholeskySpace: Let l and k denote the cholesky factors of x and y, respectively and w = l(l^-1vl^-mathrmT)_frac12, where (cdot)_frac12 denotes the lower triangular matrix with the diagonal multiplied by frac12. With u the parallel transport on CholeskySpace from l to k. The formula hear reads\n\n    mathcal P_ygets x(v) = ku^mathrmT + uk^mathrmT\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Statistics-1","page":"Symmetric positive definite","title":"Statistics","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite.html#","page":"Symmetric positive definite","title":"Symmetric positive definite","text":"Modules = [Manifolds]\nPages   = [\"SymmetricPositiveDefinite.jl\"]\nOrder = [:function]\nFilter = t -> t === mean","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#Statistics.mean-Tuple{SymmetricPositiveDefinite,Any}","page":"Symmetric positive definite","title":"Statistics.mean","text":"mean(\n    M::SymmetricPositiveDefinite,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method = GeodesicInterpolation();\n    kwargs...,\n)\n\nCompute the Riemannian mean of x using GeodesicInterpolation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Literature-1","page":"Symmetric positive definite","title":"Literature","text":"","category":"section"},{"location":"index.html#Manifolds-1","page":"Home","title":"Manifolds","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"The package Manifolds aims to provide both a unified interface to define and use manifolds as well as a library of manifolds to use for your projects.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Modules = [Manifolds, ManifoldsBase]\nPages = [\"Manifolds.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"index.html#Manifolds.AbstractEstimationMethod","page":"Home","title":"Manifolds.AbstractEstimationMethod","text":"AbstractEstimationMethod\n\nAbstract type for defining statistical estimation methods.\n\n\n\n\n\n","category":"type"},{"location":"index.html#Manifolds.PolarInverseRetraction","page":"Home","title":"Manifolds.PolarInverseRetraction","text":"PolarInverseRetraction <: AbstractInverseRetractionMethod\n\nInverse retractions that are based on a singular value decomposition of the matrix / matrices for point and tangent vector on a Manifold\n\n\n\n\n\n","category":"type"},{"location":"index.html#Manifolds.PolarRetraction","page":"Home","title":"Manifolds.PolarRetraction","text":"PolarRetraction <: AbstractRetractionMethod\n\nRetractions that are based on singular value decompositions of the matrix / matrices for point and tangent vector on a Manifold\n\n\n\n\n\n","category":"type"},{"location":"index.html#Manifolds.ProjectionInverseRetraction","page":"Home","title":"Manifolds.ProjectionInverseRetraction","text":"ProjectionInverseRetraction <: AbstractInverseRetractionMethod\n\nInverse retractions that are based on a projection (or its inversion).\n\n\n\n\n\n","category":"type"},{"location":"index.html#Manifolds.ProjectionRetraction","page":"Home","title":"Manifolds.ProjectionRetraction","text":"ProjectionRetraction <: AbstractRetractionMethod\n\nRetractions that are based on projection and usually addition in the embedding.\n\n\n\n\n\n","category":"type"},{"location":"index.html#Manifolds.QRInverseRetraction","page":"Home","title":"Manifolds.QRInverseRetraction","text":"QRInverseRetraction <: AbstractInverseRetractionMethod\n\nInverse retractions that are based on a QR decomposition of the matrix / matrices for point and tangent vector on a Manifold\n\n\n\n\n\n","category":"type"},{"location":"index.html#Manifolds.QRRetraction","page":"Home","title":"Manifolds.QRRetraction","text":"QRRetraction <: AbstractRetractionMethod\n\nRetractions that are based on a QR decomposition of the matrix / matrices for point and tangent vector on a Manifold\n\n\n\n\n\n","category":"type"},{"location":"index.html#Manifolds.hat-Tuple{Manifold,Any,Any}","page":"Home","title":"Manifolds.hat","text":"hat(M::Manifold, x, vâ±)\n\nGiven a basis e_i on the tangent space at a point x and tangent component vector v^i, compute the equivalent vector representation v=v^i e_i, where Einstein summation notation is used:\n\nwedge v^i mapsto v^i e_i\n\nFor array manifolds, this converts a vector representation of the tangent vector to an array representation. The vee map is the hat map's inverse.\n\n\n\n","category":"method"},{"location":"index.html#Manifolds.vee-Tuple{Manifold,Any,Any}","page":"Home","title":"Manifolds.vee","text":"vee(M::Manifold, x, v)\n\nGiven a basis e_i on the tangent space at a point x and tangent vector v, compute the vector components v^i, such that v = v^i e_i, where Einstein summation notation is used:\n\nvee v^i e_i mapsto v^i\n\nFor array manifolds, this converts an array representation of the tangent vector to a vector representation. The hat map is the vee map's inverse.\n\n\n\n","category":"method"},{"location":"index.html#Decorators-1","page":"Home","title":"Decorators","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Array manifold\nMetric manifold","category":"page"},{"location":"statistics.html#Statistics-1","page":"Statistics","title":"Statistics","text":"","category":"section"},{"location":"statistics.html#","page":"Statistics","title":"Statistics","text":"Modules = [Manifolds,ManifoldsBase]\nPages = [\"statistics.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"statistics.html#Manifolds.CyclicProximalPointEstimation","page":"Statistics","title":"Manifolds.CyclicProximalPointEstimation","text":"CyclicProximalPointEstimation <: AbstractEstimationMethod\n\nMethod for estimation using the cyclic proximal point technique.\n\n\n\n\n\n","category":"type"},{"location":"statistics.html#Manifolds.GeodesicInterpolation","page":"Statistics","title":"Manifolds.GeodesicInterpolation","text":"GeodesicInterpolation <: AbstractEstimationMethod\n\nRepeated weighted geodesic interpolation method for estimating the Riemannian center of mass.\n\nThe algorithm proceeds with the following simple online update:\n\nbeginaligned\nmu_1 = x_1\nt_k = fracw_ksum_i=1^k w_i\nmu_k = gamma_mu_k-1(x_k t_k)\nendaligned\n\nwhere x_k are points, w_k are weights, mu_k is the kth estimate of the mean, and gamma_x(y t) is the point at time t along the shortest_geodesic between points xy in mathcal M. The algorithm terminates when all x_k have been considered. In the Euclidean case, this exactly computes the weighted mean.\n\nThe algorithm has been shown to converge asymptotically with the sample size for the following manifolds equipped with their default metrics when all sampled points are in an open geodesic ball about the mean with corresponding radius (see GeodesicInterpolationWithinRadius):\n\nAll simply connected complete Riemannian manifolds with non-positive sectional curvature at radius infty [Cheng2016], in particular:\nEuclidean\nSymmetricPositiveDefinite [Ho2013]\nOther manifolds:\nSphere: fracpi2 [Salehian2015]\nGrassmann: fracpi4 [Chakraborty2015]\nStiefel/Rotations: fracpi2 sqrt 2 [Chakraborty2019]\n\nFor online variance computation, the algorithm additionally uses an analogous recursion to the weighted Welford algorithm [West1979].\n\n[Ho2013]: Ho J.; Cheng G.; Salehian H.; Vemuri B. C.; Recursive Karcher expectation estimators and geometric law of large numbers. Proceedings of the 16th International Conference on Artificial Intelligence and Statistics (2013), pp. 325â€“332. pdf.\n\n[Salehian2015]: Salehian H.; Chakraborty R.; Ofori E.; Vaillancourt D.; An efficient recursive estimator of the FreÌchet mean on a hypersphere with applications to Medical Image Analysis. Mathematical Foundations of Computational Anatomy (2015). pdf.\n\n[Chakraborty2015]: Chakraborty R.; Vemuri B. C.; Recursive FrÃ©chet Mean Computation on the Grassmannian and Its Applications to Computer Vision. Proceedings of the IEEE International Conference on Computer Vision (ICCV) (2015), pp. 4229-4237. doi: 10.1109/ICCV.2015.481, link.\n\n[Cheng2016]: Cheng G.; Ho J.; Salehian H.; Vemuri B. C.; Recursive Computation of the FrÃ©chet Mean on Non-positively Curved Riemannian Manifolds with Applications. Riemannian Computing in Computer Vision. Springer, Cham (2016), pp. 21-43. doi: 10.1007/978-3-319-22957-7_2, pdf.\n\n[Chakraborty2019]: Chakraborty R.; Vemuri B. C.; Statistics on the (compact) Stiefel manifold: Theory and Applications. The Annals of Statistics (2019), 47(1), pp. 415-438. doi: 10.1214/18-AOS1692, arxiv: 1708.00045.\n\n[West1979]: West D. H. D.; Updating Mean and Variance Estimates: An Improved Method. Communications of the ACM (1979), 22(9), pp. 532â€“535. doi: 10.1145/359146.359153.\n\n\n\n","category":"type"},{"location":"statistics.html#Manifolds.GeodesicInterpolationWithinRadius","page":"Statistics","title":"Manifolds.GeodesicInterpolationWithinRadius","text":"GeodesicInterpolationWithinRadius{T} <: AbstractEstimationMethod\n\nEstimation of Riemannian center of mass using GeodesicInterpolation with fallback to GradientDescentEstimation if any points are outside of a geodesic ball of specified radius around the mean.\n\nConstructor\n\nGeodesicInterpolationWithinRadius(radius)\n\n\n\n\n\n","category":"type"},{"location":"statistics.html#Manifolds.GradientDescentEstimation","page":"Statistics","title":"Manifolds.GradientDescentEstimation","text":"GradientDescentEstimation <: AbstractEstimationMethod\n\nMethod for estimation using gradient descent.\n\n\n\n\n\n","category":"type"},{"location":"statistics.html#Statistics.mean!-Tuple{Manifold,Vararg{Any,N} where N}","page":"Statistics","title":"Statistics.mean!","text":"mean!(M::Manifold, y, x::AbstractVector[, w::AbstractWeights]; kwargs...)\nmean!(\n    M::Manifold,\n    y,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::AbstractEstimationMethod;\n    kwargs...,\n)\n\nCompute the mean in-place in y.\n\n\n\n","category":"method"},{"location":"statistics.html#Statistics.mean-Tuple{Manifold,AbstractArray{T,1} where T,AbstractArray{T,1} where T,GeodesicInterpolationWithinRadius}","page":"Statistics","title":"Statistics.mean","text":"mean(\n    M::Manifold,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::GeodesicInterpolationWithinRadius;\n    kwargs...,\n)\n\nEstimate the Riemannian center of mass of x using GeodesicInterpolationWithinRadius.\n\nSee mean for a description of kwargs.\n\n\n\n\n\n","category":"method"},{"location":"statistics.html#Statistics.mean-Tuple{Manifold,AbstractArray{T,1} where T,AbstractArray{T,1} where T,GeodesicInterpolation}","page":"Statistics","title":"Statistics.mean","text":"mean(\n    M::Manifold,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::GeodesicInterpolation;\n    shuffle_rng=nothing,\n    retraction::AbstractRetractionMethod = ExponentialRetraction(),\n    inverse_retraction::AbstractInverseRetractionMethod = LogarithmicInverseRetraction(),\n    kwargs...,\n)\n\nEstimate the Riemannian center of mass of x in an online fashion using repeated weighted geodesic interpolation. See GeodesicInterpolation for details.\n\nIf shuffle_rng is provided, it is used to shuffle the order in which the points are considered for computing the mean.\n\nOptionally, pass retraction and inverse_retraction method types to specify the (inverse) retraction.\n\n\n\n\n\n","category":"method"},{"location":"statistics.html#Statistics.mean-Tuple{Manifold,Vararg{Any,N} where N}","page":"Statistics","title":"Statistics.mean","text":"mean(M::Manifold, x::AbstractVector[, w::AbstractWeights]; kwargs...)\n\nCompute the (optionally weighted) Riemannian center of mass also known as Karcher mean of the vector x of points on the Manifold M, defined as the point that satisfies the minimizer\n\nargmin_yinmathcal M frac12 sum_i=1^n w_i sum_i=1^n w_imathrmd_mathcal M^2(yx_i)\n\nwhere mathrmd_mathcal M denotes the Riemannian distance.\n\nIn the general case, the GradientDescentEstimation is used to compute the mean. However, this default may be overloaded for specific manifolds.\n\nmean(\n    M::Manifold,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::AbstractEstimationMethod;\n    kwargs...,\n)\n\nCompute the mean using the specified method.\n\nmean(\n    M::Manifold,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::GradientDescentEstimation;\n    x0=x[1],\n    stop_iter=100,\n    retraction::AbstractRetractionMethod = ExponentialRetraction(),\n    inverse_retraction::AbstractInverseRetractionMethod = LogarithmicInverseRetraction(),\n    kwargs...,\n)\n\nCompute the mean using the gradient descent scheme GradientDescentEstimation.\n\nOptionally, provide x0, the starting point (by default set to the first data point). stop_iter denotes the maximal number of iterations to perform and the kwargs... are passed to isapprox to stop, when the minimal change between two iterates is small. For more stopping criteria check the Manopt.jl package and use a solver therefrom.\n\nOptionally, pass retraction and inverse_retraction method types to specify the (inverse) retraction.\n\nThe algorithm is further described in [Afsari2013].\n\n[Afsari2013]: Afsari, B; Tron, R.; Vidal, R.: On the Convergence of Gradient Descent for Finding the Riemannian Center of Mass, SIAM Journal on Control and Optimization (2013), 51(3), pp. 2230â€“2260, doi: 10.1137/12086282X, arxiv: 1201.0925\n\n\n\n","category":"method"},{"location":"statistics.html#Statistics.median!-Tuple{Manifold,Vararg{Any,N} where N}","page":"Statistics","title":"Statistics.median!","text":"median!(M::Manifold, y, x::AbstractVector[, w::AbstractWeights]; kwargs...)\nmedian!(\n    M::Manifold,\n    y,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::AbstractEstimationMethod;\n    kwargs...,\n)\n\ncomputes the median in-place in y.\n\n\n\n","category":"method"},{"location":"statistics.html#Statistics.median-Tuple{Manifold,Vararg{Any,N} where N}","page":"Statistics","title":"Statistics.median","text":"median(M::Manifold, x::AbstractVector[, w::AbstractWeights]; kwargs...)\n\nCompute the (optionally weighted) Riemannian median of the vector x of points on the Manifold M, defined as the point that satisfies the minimizer\n\nargmin_yinmathcal M frac1sum_i=1^n w_i sum_i=1^n w_imathrmd_mathcal M(yx_i)\n\nwhere mathrmd_mathcal M denotes the Riemannian distance. This function is nonsmooth (i.e nondifferentiable).\n\nIn the general case, the CyclicProximalPointEstimation is used to compute the median. However, this default may be overloaded for specific manifolds.\n\nmedian(\n    M::Manifold,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::AbstractEstimationMethod;\n    kwargs...,\n)\n\nCompute the median using the specified method.\n\nmedian(\n    M::Manifold,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::CyclicProximalPointEstimation;\n    x0=x[1],\n    stop_iter=1000000,\n    retraction::AbstractRetractionMethod = ExponentialRetraction(),\n    inverse_retraction::AbstractInverseRetractionMethod = LogarithmicInverseRetraction(),\n    kwargs...,\n)\n\nCompute the median using CyclicProximalPointEstimation.\n\nOptionally, provide x0, the starting point (by default set to the first data point). stop_iter denotes the maximal number of iterations to perform and the kwargs... are passed to isapprox to stop, when the minimal change between two iterates is small. For more stopping criteria check the Manopt.jl package and use a solver therefrom.\n\nOptionally, pass retraction and inverse_retraction method types to specify the (inverse) retraction.\n\nThe algorithm is further described in [BaÄÃ¡k2014].\n\n[BaÄÃ¡k2014]: BaÄÃ¡k, M: Computing Medians and Means in Hadamard Spaces. SIAM Journal on Optimization (2014), 24(3), pp. 1542â€“1566, doi: 10.1137/140953393, arxiv: 1210.2145\n\n\n\n","category":"method"},{"location":"statistics.html#Statistics.std-Tuple{Manifold,Vararg{Any,N} where N}","page":"Statistics","title":"Statistics.std","text":"std(M, x, m=mean(M, x); corrected=true, kwargs...)\nstd(M, x, w::AbstractWeights, m=mean(M, x, w); corrected=false, kwargs...)\n\ncompute the optionally weighted standard deviation of a Vector x of n data points on the Manifold M, i.e.\n\nsqrtfrac1c sum_i=1^n w_i d_mathcal M^2 (x_im)\n\nwhere c is a correction term, see Statistics.std. The mean of x can be specified as m, and the corrected variance can be activated by setting corrected=true.\n\n\n\n","category":"method"},{"location":"statistics.html#Statistics.var-Tuple{Manifold,Any}","page":"Statistics","title":"Statistics.var","text":"var(M, x, m=mean(M, x); corrected=true, kwargs...)\nvar(M, x, w::AbstractWeights, m=mean(M, x, w); corrected=false, kwargs...)\n\ncompute the (optionally weighted) variance of a Vector x of n data points on the Manifold M, i.e.\n\nfrac1c sum_i=1^n w_i d_mathcal M^2 (x_im)\n\nwhere c is a correction term, see Statistics.var. The mean of x can be specified as m, and the corrected variance can be activated by setting corrected=true. All further kwargs... are passed to the computation of the mean (if that is not provided).\n\n\n\n","category":"method"},{"location":"statistics.html#StatsBase.kurtosis-Tuple{Manifold,AbstractArray{T,1} where T,StatsBase.AbstractWeights}","page":"Statistics","title":"StatsBase.kurtosis","text":"kurtosis(M::Manifold, x::AbstractVector, k::Int[, w::AbstractWeights], m=mean(M, x[, w]))\n\nCompute the excess kurtosis of points in x on manifold M. Optionally provide weights w and/or a precomputed mean m.\n\n\n\n\n\n","category":"method"},{"location":"statistics.html#StatsBase.mean_and_std-Tuple{Manifold,Vararg{Any,N} where N}","page":"Statistics","title":"StatsBase.mean_and_std","text":"mean_and_std(M::Manifold, x::AbstractVector[, w::AbstractWeights]; kwargs...) -> (mean, std)\n\nCompute the mean and the standard deviation std simultaneously.\n\nmean_and_std(\n    M::Manifold,\n    x::AbstractVector\n    [w::AbstractWeights,]\n    method::AbstractEstimationMethod;\n    kwargs...,\n) -> (mean, var)\n\nUse the method for simultaneously computing the mean and standard deviation. To use a mean-specific method, call mean and then std.\n\n\n\n","category":"method"},{"location":"statistics.html#StatsBase.mean_and_var-Tuple{Manifold,AbstractArray{T,1} where T,StatsBase.AbstractWeights,GeodesicInterpolationWithinRadius}","page":"Statistics","title":"StatsBase.mean_and_var","text":"mean_and_var(\n    M::Manifold,\n    x::AbstractVector\n    [w::AbstractWeights,]\n    method::GeodesicInterpolationWithinRadius;\n    kwargs...,\n) -> (mean, var)\n\nUse repeated weighted geodesic interpolation to estimate the mean. Simultaneously, use a Welford-like recursion to estimate the variance.\n\nSee GeodesicInterpolationWithinRadius and mean_and_var for more information.\n\n\n\n\n\n","category":"method"},{"location":"statistics.html#StatsBase.mean_and_var-Tuple{Manifold,AbstractArray{T,1} where T,StatsBase.AbstractWeights,GeodesicInterpolation}","page":"Statistics","title":"StatsBase.mean_and_var","text":"mean_and_var(\n    M::Manifold,\n    x::AbstractVector\n    [w::AbstractWeights,]\n    method::GeodesicInterpolation;\n    shuffle_rng::Union{AbstractRNG,Nothing} = nothing,\n    retraction::AbstractRetractionMethod = ExponentialRetraction(),\n    inverse_retraction::AbstractInverseRetractionMethod = LogarithmicInverseRetraction(),\n    kwargs...,\n) -> (mean, var)\n\nUse the repeated weighted geodesic interpolation to estimate the mean. Simultaneously, use a Welford-like recursion to estimate the variance.\n\nIf shuffle_rng is provided, it is used to shuffle the order in which the points are considered. Optionally, pass retraction and inverse_retraction method types to specify the (inverse) retraction.\n\nSee GeodesicInterpolation for details on the geodesic interpolation method.\n\nnote: Note\nThe Welford algorithm for the variance is experimental and is not guaranteed to give accurate results except on Euclidean.\n\n\n\n","category":"method"},{"location":"statistics.html#StatsBase.mean_and_var-Tuple{Manifold,Vararg{Any,N} where N}","page":"Statistics","title":"StatsBase.mean_and_var","text":"mean_and_var(M::Manifold, x::AbstractVector[, w::AbstractWeights]; kwargs...) -> (mean, var)\n\nCompute the mean and the variance simultaneously. See those functions for a description of the arguments.\n\nmean_and_var(\n    M::Manifold,\n    x::AbstractVector\n    [w::AbstractWeights,]\n    method::AbstractEstimationMethod;\n    kwargs...,\n) -> (mean, var)\n\nUse the method for simultaneously computing the mean and variance. To use a mean-specific method, call mean and then var.\n\n\n\n","category":"method"},{"location":"statistics.html#StatsBase.moment","page":"Statistics","title":"StatsBase.moment","text":"moment(M::Manifold, x::AbstractVector, k::Int[, w::AbstractWeights], m=mean(M, x[, w]))\n\nCompute the kth central moment of points in x on manifold M. Optionally provide weights w and/or a precomputed mean.\n\n\n\n\n\n","category":"function"},{"location":"statistics.html#StatsBase.skewness-Tuple{Manifold,AbstractArray{T,1} where T,StatsBase.AbstractWeights}","page":"Statistics","title":"StatsBase.skewness","text":"skewness(M::Manifold, x::AbstractVector, k::Int[, w::AbstractWeights], m=mean(M, x[, w]))\n\nCompute the standardized skewness of points in x on manifold M. Optionally provide weights w and/or a precomputed mean m.\n\n\n\n\n\n","category":"method"},{"location":"statistics.html#Literature-1","page":"Statistics","title":"Literature","text":"","category":"section"},{"location":"manifolds/group.html#Group-manifolds-and-actions-1","page":"Group manifold","title":"Group manifolds and actions","text":"","category":"section"},{"location":"manifolds/group.html#","page":"Group manifold","title":"Group manifold","text":"Lie groups, groups that are Manifolds with a smooth binary group operation AbstractGroupOperation, are implemented as subtypes of AbstractGroupManifold or by decorating an existing manifold with a group operation using GroupManifold.","category":"page"},{"location":"manifolds/group.html#","page":"Group manifold","title":"Group manifold","text":"The common addition and multiplication group operations of AdditionOperation and MultiplicationOperation are provided, though their behavior may be customized for a specific group.","category":"page"},{"location":"manifolds/group.html#Contents-1","page":"Group manifold","title":"Contents","text":"","category":"section"},{"location":"manifolds/group.html#","page":"Group manifold","title":"Group manifold","text":"Pages = [\"group.md\"]\nDepth = 3","category":"page"},{"location":"manifolds/group.html#Groups-1","page":"Group manifold","title":"Groups","text":"","category":"section"},{"location":"manifolds/group.html#Group-manifold-1","page":"Group manifold","title":"Group manifold","text":"","category":"section"},{"location":"manifolds/group.html#","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.AbstractGroupManifold","page":"Group manifold","title":"Manifolds.AbstractGroupManifold","text":"AbstractGroupManifold{<:AbstractGroupOperation} <: Manifold\n\nAbstract type for a Lie group, a group that is also a smooth manifold with an AbstractGroupOperation, a smooth binary operation. AbstractGroupManifolds must implement at least inv, identity, compose, and translate_diff.\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.AbstractGroupOperation","page":"Group manifold","title":"Manifolds.AbstractGroupOperation","text":"AbstractGroupOperation\n\nAbstract type for smooth binary operations  on elements of a Lie group G:\n\n G  G  G\n\nAn operation can be either defined for a specific AbstractGroupManifold or in general, by defining for an operation Op the following methods:\n\nidentity!(::AbstractGroupManifold{Op}, y, x)\nidentity(::AbstractGroupManifold{Op}, x)\ninv!(::AbstractGroupManifold{Op}, y, x)\ninv(::AbstractGroupManifold{Op}, x)\ncompose(::AbstractGroupManifold{Op}, x, y)\ncompose!(::AbstractGroupManifold{Op}, z, x, y)\n\nNote that a manifold is connected with an operation by wrapping it with a decorator, AbstractGroupManifold. In typical cases the concrete wrapper GroupManifold can be used.\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.ActionDirection","page":"Group manifold","title":"Manifolds.ActionDirection","text":"ActionDirection\n\nDirection of action on a manifold, either LeftAction or RightAction.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.AdditionOperation","page":"Group manifold","title":"Manifolds.AdditionOperation","text":"AdditionOperation <: AbstractGroupOperation\n\nGroup operation that consists of simple addition.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.GroupManifold","page":"Group manifold","title":"Manifolds.GroupManifold","text":"GroupManifold{M<:Manifold,O<:AbstractGroupOperation} <: AbstractGroupManifold{O}\n\nDecorator for a smooth manifold that equips the manifold with a group operation, thus making it a Lie group. See AbstractGroupManifold for more details.\n\nGroup manifolds by default forward metric-related operations to the wrapped manifold.\n\nConstructor\n\nGroupManifold(manifold, op)\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.Identity","page":"Group manifold","title":"Manifolds.Identity","text":"Identity(G::AbstractGroupManifold)\n\nThe group identity element e  G.\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.LeftAction","page":"Group manifold","title":"Manifolds.LeftAction","text":"LeftAction()\n\nLeft action of a group on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.MultiplicationOperation","page":"Group manifold","title":"Manifolds.MultiplicationOperation","text":"MultiplicationOperation <: AbstractGroupOperation\n\nGroup operation that consists of multiplication.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.RightAction","page":"Group manifold","title":"Manifolds.RightAction","text":"RightAction()\n\nRight action of a group on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Base.identity-Tuple{Manifold,Any}","page":"Group manifold","title":"Base.identity","text":"identity(G::AbstractGroupManifold, x)\n\nIdentity element e  G, such that for any element x  G, x circ e = e circ x = x. The returned element is of a similar type to x.\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Base.inv-Tuple{Manifold,Any}","page":"Group manifold","title":"Base.inv","text":"inv(G::AbstractGroupManifold, x)\n\nInverse x^-1  G of an element x  G, such that x circ x^-1 = x^-1 circ x = e  G.\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.base_group-Tuple{Manifold}","page":"Group manifold","title":"Manifolds.base_group","text":"base_group(M::Manifold) -> AbstractGroupManifold\n\nUndecorate M until an AbstractGroupManifold is encountered. Return an error if the base_manifold is reached without encountering a group.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.compose-Tuple{Manifold,Any,Any}","page":"Group manifold","title":"Manifolds.compose","text":"compose(G::AbstractGroupManifold, x, y)\n\nCompose elements xy  G using the group operation x circ y.\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.inv!-Tuple{Manifold,Any,Any}","page":"Group manifold","title":"Manifolds.inv!","text":"inv!(G::AbstractGroupManifold, y, x)\n\nInverse x^-1  G of an element x  G, such that x circ x^-1 = x^-1 circ x = e  G. The result is saved to y.\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.inverse_translate!-Tuple{Manifold,Any,Any,Any}","page":"Group manifold","title":"Manifolds.inverse_translate!","text":"inverse_translate!(G::AbstractGroupManifold, z, x, y, [conv::ActionDirection=Left()])\n\nFor group elements xy  G, inverse translate y by x with the specified convention, either left L_x^-1 or right R_x^-1, defined as\n\nbeginaligned\nL_x^-1  y  x^-1 circ y\nR_x^-1  y  y circ x^-1\nendaligned\n\nResult is saved in z.\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.inverse_translate-Tuple{Manifold,Any,Any}","page":"Group manifold","title":"Manifolds.inverse_translate","text":"inverse_translate(G::AbstractGroupManifold, x, y, [conv::ActionDirection=Left()])\n\nFor group elements xy  G, inverse translate y by x with the specified convention, either left L_x^-1 or right R_x^-1, defined as\n\nbeginaligned\nL_x^-1  y  x^-1 circ y\nR_x^-1  y  y circ x^-1\nendaligned\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.inverse_translate_diff-Tuple{Manifold,Any,Any,Any}","page":"Group manifold","title":"Manifolds.inverse_translate_diff","text":"inverse_translate_diff(G::AbstractGroupManifold, x, y, v[, conv::ActionDirection=Left()])\n\nFor group elements xy  G and tangent vector v  T_y G, compute the inverse of the action of the differential of the translation by x on v, written as ((mathrmdÏ„_x)_y)^-1 (v) = (mathrmdÏ„_x^-1)_y (v), with the specified left or right convention. The differential transports vectors:\n\nbeginaligned\n((mathrmdL_x)_y)^-1 (v)  T_y G  T_x^-1 circ y G\n((mathrmdR_x)_y)^-1 (v)  T_y G  T_y circ x^-1 G\nendaligned\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.switch_direction-Tuple{ActionDirection}","page":"Group manifold","title":"Manifolds.switch_direction","text":"switch_direction(::ActionDirection)\n\nReturns a RightAction when given a LeftAction and vice versa.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.translate!-Tuple{Manifold,Any,Any,Any}","page":"Group manifold","title":"Manifolds.translate!","text":"translate!(G::AbstractGroupManifold, z, x, y[, conv::ActionDirection=LeftAction()])\n\nFor group elements xy  G, translate y by x with the specified convention, either left L_x or right R_x, defined as\n\nbeginaligned\nL_x  y  x circ y\nR_x  y  y circ x\nendaligned\n\nResult of the operation is saved in z.\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.translate-Tuple{Manifold,Any,Any}","page":"Group manifold","title":"Manifolds.translate","text":"translate(G::AbstractGroupManifold, x, y[, conv::ActionDirection=LeftAction()])\n\nFor group elements xy  G, translate y by x with the specified convention, either left L_x or right R_x, defined as\n\nbeginaligned\nL_x  y  x circ y\nR_x  y  y circ x\nendaligned\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.translate_diff-Tuple{Manifold,Any,Any,Any}","page":"Group manifold","title":"Manifolds.translate_diff","text":"translate_diff(G::AbstractGroupManifold, x, y, v[, conv::ActionDirection=LeftAction()])\n\nFor group elements xy  G and tangent vector v  T_y G, compute the action of the differential of the translation by x on v, written as (mathrmdÏ„_x)_y (v), with the specified left or right convention. The differential transports vectors:\n\nbeginaligned\n(mathrmdL_x)_y (v)  T_y G  T_x circ y G\n(mathrmdR_x)_y (v)  T_y G  T_y circ x G\nendaligned\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Product-group-1","page":"Group manifold","title":"Product group","text":"","category":"section"},{"location":"manifolds/group.html#","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/product_group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.ProductGroup-Tuple{ProductManifold}","page":"Group manifold","title":"Manifolds.ProductGroup","text":"ProductGroup{T} <: GroupManifold{ProductManifold{T},ProductOperation}\n\nDecorate a product manifold with a ProductOperation.\n\nEach submanifold must also be an AbstractGroupManifold or a decorated instance of one. This type is mostly useful for equipping the direct product of group manifolds with an Identity element.\n\nConstructor\n\nProductGroup(manifold::ProductManifold)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.ProductOperation","page":"Group manifold","title":"Manifolds.ProductOperation","text":"ProductOperation <: AbstractGroupOperation\n\nDirect product group operation.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Semidirect-product-group-1","page":"Group manifold","title":"Semidirect product group","text":"","category":"section"},{"location":"manifolds/group.html#","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/semidirect_product_group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.SemidirectProductGroup-Tuple{GroupManifold,GroupManifold,AbstractGroupAction}","page":"Group manifold","title":"Manifolds.SemidirectProductGroup","text":"SemidirectProductGroup(N::GroupManifold, H::GroupManifold, A::AbstractGroupAction)\n\nA group that is the semidirect product of a normal group N and a subgroup H, written G = N _Î¸ H, where Î¸ H  N to N is an automorphism action of H on N. The group G has the composition rule\n\ng circ g = (n h) circ (n h) = (n circ Î¸_h(n) h circ h)\n\nand the inverse\n\ng^-1 = (n h)^-1 = (Î¸_h^-1(n^-1) h^-1)\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.SemidirectProductOperation","page":"Group manifold","title":"Manifolds.SemidirectProductOperation","text":"SemidirectProductOperation(action::AbstractGroupAction)\n\nGroup operation of a semidirect product group. The operation consists of the operation opN on a normal subgroup N, the operation opH on a subgroup H, and an automorphism action of elements of H on N. Only the action is stored.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Circle-group-1","page":"Group manifold","title":"Circle group","text":"","category":"section"},{"location":"manifolds/group.html#","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/circle_group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.CircleGroup","page":"Group manifold","title":"Manifolds.CircleGroup","text":"CircleGroup <: GroupManifold{Circle{â„‚},MultiplicationOperation}\n\nThe circle group is the complex circle (Circle(â„‚)) equipped with the group operation of complex multiplication (MultiplicationOperation).\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Special-orthogonal-group-1","page":"Group manifold","title":"Special orthogonal group","text":"","category":"section"},{"location":"manifolds/group.html#","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/special_orthogonal.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.SpecialOrthogonal","page":"Group manifold","title":"Manifolds.SpecialOrthogonal","text":"SpecialOrthogonal{n} <: GroupManifold{Rotations{n},MultiplicationOperation}\n\nSpecial orthogonal group mathrmSO(n) represented by rotation matrices.\n\nConstructor\n\nSpecialOrthogonal(n)\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Translation-group-1","page":"Group manifold","title":"Translation group","text":"","category":"section"},{"location":"manifolds/group.html#","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/translation_group.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.TranslationGroup","page":"Group manifold","title":"Manifolds.TranslationGroup","text":"TranslationGroup{T<:Tuple,F} <: GroupManifold{Euclidean{T,F},AdditionOperation}\n\nTranslation group mathrmT(n) represented by translation arrays.\n\nConstructor\n\nTranslationGroup(nâ‚,...,náµ¢; field = ð”½)\n\nGenerate the translation group on ð”½^nâ‚dotsnáµ¢ = Euclidean(nâ‚,...,náµ¢; field = ð”½), which is isomorphic to group itself.\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Special-Euclidean-group-1","page":"Group manifold","title":"Special Euclidean group","text":"","category":"section"},{"location":"manifolds/group.html#","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/special_euclidean.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.SpecialEuclidean","page":"Group manifold","title":"Manifolds.SpecialEuclidean","text":"SpecialEuclidean(n)\n\nSpecial Euclidean group mathrmSE(n), the group of rigid motions.\n\nmathrmSE(n) is the semidirect product of the TranslationGroup on â„^n and SpecialOrthogonal(n)\n\nmathrmSE(n)  mathrmT(n) _Î¸ mathrmSO(n)\n\nwhere Î¸ is the canonical action of mathrmSO(n) on mathrmT(n) by vector rotation.\n\nThis constructor is equivalent to calling\n\nTn = TranslationGroup(n)\nSOn = SpecialOrthogonal(n)\nSemidirectProductGroup(Tn, SOn, RotationAction(Tn, SOn))\n\nPoints on mathrmSE(n) may be represented as points on the underlying product manifold mathrmT(n) times mathrmSO(n) or as affine matrices with size (n + 1, n + 1).\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Group-actions-1","page":"Group manifold","title":"Group actions","text":"","category":"section"},{"location":"manifolds/group.html#","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/group_action.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.AbstractGroupAction","page":"Group manifold","title":"Manifolds.AbstractGroupAction","text":"AbstractGroupAction\n\nAn abstract group action on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Manifolds.apply!-Tuple{AbstractGroupAction{LeftAction},Any,Any,Any}","page":"Group manifold","title":"Manifolds.apply!","text":"apply!(A::AbstractGroupAction, y, a, x)\n\nApply action a to the point x with the rule specified by A. The result is saved in y.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.apply-Tuple{AbstractGroupAction,Any,Any}","page":"Group manifold","title":"Manifolds.apply","text":"apply(A::AbstractGroupAction, a, x)\n\nApply action a to the point x. The action is specified by A. Unless otherwise specified, right actions are defined in terms of the left action. For point x  M and action element a, the right action is\n\nx  a  a^-1  x\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.apply_diff-Tuple{AbstractGroupAction,Any,Any,Any}","page":"Group manifold","title":"Manifolds.apply_diff","text":"apply_diff(A::AbstractGroupAction, a, x, v)\n\nFor group point x  M and tangent vector v  T_x M, compute the action of the differential of the action of a  G on v, specified by rule A. Written as (mathrmdÏ„_a)_x (v), with the specified left or right convention, the differential transports vectors\n\nbeginaligned\n(mathrmdL_a)_x (v)  T_x M  T_a  x M\n(mathrmdR_a)_x (v)  T_x M  T_x  a M\nendaligned\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.base_group-Tuple{AbstractGroupAction}","page":"Group manifold","title":"Manifolds.base_group","text":"base_group(A::AbstractGroupAction)\n\nThe group that acts in action A.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.center_of_orbit","page":"Group manifold","title":"Manifolds.center_of_orbit","text":"center_of_orbit(\n    A::AbstractGroupAction,\n    pts,\n    q,\n    mean_method::AbstractEstimationMethod = GradientDescentEstimation()\n)\n\nCalculate an action element g of action A that is the mean element of the orbit of q with respect to given set of points pts. The mean is calculated using the method mean_method.\n\nThe orbit of q with respect to the action of a group G is the set `math O = \\{ g â‹… q : g âˆˆ G \\}. This function is useful for computing means on quotients of manifolds by a Lie group action.\n\n\n\n","category":"function"},{"location":"manifolds/group.html#Manifolds.direction-Union{Tuple{AbstractGroupAction{AD}}, Tuple{AD}} where AD","page":"Group manifold","title":"Manifolds.direction","text":"direction(::AbstractGroupAction{AD}) -> AD\n\nGet the direction of the action\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.g_manifold-Tuple{AbstractGroupAction}","page":"Group manifold","title":"Manifolds.g_manifold","text":"g_manifold(A::AbstractGroupAction)\n\nThe manifold the action A acts upon.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.inverse_apply!-Tuple{AbstractGroupAction,Any,Any,Any}","page":"Group manifold","title":"Manifolds.inverse_apply!","text":"inverse_apply!(A::AbstractGroupAction, y, a, x)\n\nApply inverse of action a to the point x with the rule specified by A. The result is saved in y.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.inverse_apply-Tuple{AbstractGroupAction,Any,Any}","page":"Group manifold","title":"Manifolds.inverse_apply","text":"inverse_apply(A::AbstractGroupAction, a, x)\n\nApply inverse of action a to the point x. The action is specified by A.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.inverse_apply_diff-Tuple{AbstractGroupAction,Any,Any,Any}","page":"Group manifold","title":"Manifolds.inverse_apply_diff","text":"inverse_apply_diff(A::AbstractGroupAction, a, x, v)\n\nFor group point x  M and tangent vector v  T_x M, compute the action of the differential of the inverse action of a  G on v, specified by rule A. Written as (mathrmdÏ„_a)_x^-1 (v), with the specified left or right convention, the differential transports vectors\n\nbeginaligned\n(mathrmdL_a)_x^-1 (v)  T_x M  T_a^-1  x M\n(mathrmdR_a)_x^-1 (v)  T_x M  T_x  a^-1 M\nendaligned\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.optimal_alignment!-Tuple{AbstractGroupAction,Any,Any,Any}","page":"Group manifold","title":"Manifolds.optimal_alignment!","text":"optimal_alignment!(A::AbstractGroupAction, y, x1, x2)\n\nCalculate an action element of action A that acts upon x1 to produce the element closest to x2. The result is written to y.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Manifolds.optimal_alignment-Tuple{AbstractGroupAction,Any,Any}","page":"Group manifold","title":"Manifolds.optimal_alignment","text":"optimal_alignment(A::AbstractGroupAction, x1, x2)\n\nCalculate an action element of action A that acts upon x1 to produce the element closest to x2 in the metric of the G-manifold:\n\nargmin_g  G d_M(g  x_1 x_2)\n\nwhere G is the group that acts on the G-manifold M.\n\n\n\n","category":"method"},{"location":"manifolds/group.html#Group-operation-action-1","page":"Group manifold","title":"Group operation action","text":"","category":"section"},{"location":"manifolds/group.html#","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/group_operation_action.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.GroupOperationAction","page":"Group manifold","title":"Manifolds.GroupOperationAction","text":"GroupOperationAction(group::AbstractGroupManifold, AD::ActionDirection = LeftAction())\n\nAction of a group upon itself via left or right translation.\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Rotation-action-1","page":"Group manifold","title":"Rotation action","text":"","category":"section"},{"location":"manifolds/group.html#","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/rotation_action.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.RotationAction","page":"Group manifold","title":"Manifolds.RotationAction","text":"RotationAction(\n    M::Manifold,\n    SOn::SpecialOrthogonal,\n    AD::ActionDirection = LeftAction(),\n)\n\nSpace of actions of the SpecialOrthogonal group mathrmSO(n) on a Euclidean-like manifold M of dimension n.\n\n\n\n","category":"type"},{"location":"manifolds/group.html#Translation-action-1","page":"Group manifold","title":"Translation action","text":"","category":"section"},{"location":"manifolds/group.html#","page":"Group manifold","title":"Group manifold","text":"Modules = [Manifolds]\nPages = [\"groups/translation_action.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/group.html#Manifolds.TranslationAction","page":"Group manifold","title":"Manifolds.TranslationAction","text":"TranslationAction(\n    M::Manifold,\n    Rn::TranslationGroup,\n    AD::ActionDirection = LeftAction(),\n)\n\nSpace of actions of the TranslationGroup mathrmT(n) on a Euclidean-like manifold M.\n\nThe left and right actions are equivalent.\n\n\n\n","category":"type"}]
}
